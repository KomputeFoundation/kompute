<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kompute: kp::Tensor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kompute
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kp</b></li><li class="navelem"><a class="el" href="classkp_1_1Tensor.html">Tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classkp_1_1Tensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">kp::Tensor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Tensor_8hpp_source.html">Tensor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for kp::Tensor:</div>
<div class="dyncontent">
<div class="center"><img src="classkp_1_1Tensor__inherit__graph.png" border="0" usemap="#akp_1_1Tensor_inherit__map" alt="Inheritance graph"/></div>
<map name="akp_1_1Tensor_inherit__map" id="akp_1_1Tensor_inherit__map">
<area shape="rect" title=" " alt="" coords="29,5,117,32"/>
<area shape="rect" href="classkp_1_1TensorT.html" title=" " alt="" coords="5,80,140,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1b2af1c0e8dc0f154e11780e7103beb4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> { <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">eDevice</a> = 0
, <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a746241fcf54388332f43a13dd4a82f0a">eHost</a> = 1
, <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4ae1a7e733531f08074becd467959f0521">eStorage</a> = 2
 }</td></tr>
<tr class="separator:a1b2af1c0e8dc0f154e11780e7103beb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1a3b45fa490ebd1b628d373e89f903"><td class="memItemLeft" align="right" valign="top"><a id="adf1a3b45fa490ebd1b628d373e89f903"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>TensorDataTypes</b> { <br />
&#160;&#160;<b>eBool</b> = 0
, <b>eInt</b> = 1
, <b>eUnsignedInt</b> = 2
, <b>eFloat</b> = 3
, <br />
&#160;&#160;<b>eDouble</b> = 4
<br />
 }</td></tr>
<tr class="separator:adf1a3b45fa490ebd1b628d373e89f903"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acfce13e44a6ab46d7ebf6618b09bcd14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#acfce13e44a6ab46d7ebf6618b09bcd14">Tensor</a> (std::shared_ptr&lt; vk::PhysicalDevice &gt; physicalDevice, std::shared_ptr&lt; vk::Device &gt; device, void *<a class="el" href="classkp_1_1Tensor.html#af4c8d1bdeb1e057bd0d1aea1207bc98e">data</a>, uint32_t elementTotalCount, uint32_t elementMemorySize, const TensorDataTypes &amp;<a class="el" href="classkp_1_1Tensor.html#a4addb015014f14da3d6019400c9771e4">dataType</a>, const <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> &amp;<a class="el" href="classkp_1_1Tensor.html#a59452f1c62fd738536bb0a6cbf8d896b">tensorType</a>=<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a>)</td></tr>
<tr class="separator:acfce13e44a6ab46d7ebf6618b09bcd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71ac92ecaac55d9bcc75f1571bfd47f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#ab71ac92ecaac55d9bcc75f1571bfd47f">~Tensor</a> ()</td></tr>
<tr class="separator:ab71ac92ecaac55d9bcc75f1571bfd47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece585e97c20ed7133fdfe9fabed9bd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#aece585e97c20ed7133fdfe9fabed9bd6">rebuild</a> (void *<a class="el" href="classkp_1_1Tensor.html#af4c8d1bdeb1e057bd0d1aea1207bc98e">data</a>, uint32_t elementTotalCount, uint32_t elementMemorySize)</td></tr>
<tr class="separator:aece585e97c20ed7133fdfe9fabed9bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdbcb7abaad8f3e3a392741ea5ad275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a5cdbcb7abaad8f3e3a392741ea5ad275">destroy</a> ()</td></tr>
<tr class="separator:a5cdbcb7abaad8f3e3a392741ea5ad275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ae7f0b57fd8e57570ab63962a97f36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#af2ae7f0b57fd8e57570ab63962a97f36">isInit</a> ()</td></tr>
<tr class="separator:af2ae7f0b57fd8e57570ab63962a97f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59452f1c62fd738536bb0a6cbf8d896b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a59452f1c62fd738536bb0a6cbf8d896b">tensorType</a> ()</td></tr>
<tr class="separator:a59452f1c62fd738536bb0a6cbf8d896b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8b7b81913863523c7a3e580cf91d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#afe8b7b81913863523c7a3e580cf91d8e">recordCopyFrom</a> (const vk::CommandBuffer &amp;commandBuffer, std::shared_ptr&lt; <a class="el" href="classkp_1_1Tensor.html">Tensor</a> &gt; copyFromTensor)</td></tr>
<tr class="separator:afe8b7b81913863523c7a3e580cf91d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac565adf645121120c0b9ec31c04c743b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#ac565adf645121120c0b9ec31c04c743b">recordCopyFromStagingToDevice</a> (const vk::CommandBuffer &amp;commandBuffer)</td></tr>
<tr class="separator:ac565adf645121120c0b9ec31c04c743b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4be54f0063ffc1687006d6f0b417fcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#ab4be54f0063ffc1687006d6f0b417fcb">recordCopyFromDeviceToStaging</a> (const vk::CommandBuffer &amp;commandBuffer)</td></tr>
<tr class="separator:ab4be54f0063ffc1687006d6f0b417fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bacad91d866079585f18feb3ec6d8f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a1bacad91d866079585f18feb3ec6d8f7">recordPrimaryBufferMemoryBarrier</a> (const vk::CommandBuffer &amp;commandBuffer, vk::AccessFlagBits srcAccessMask, vk::AccessFlagBits dstAccessMask, vk::PipelineStageFlagBits srcStageMask, vk::PipelineStageFlagBits dstStageMask)</td></tr>
<tr class="separator:a1bacad91d866079585f18feb3ec6d8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c2ef6acb0b74dcba7d92c870b2daa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#ae1c2ef6acb0b74dcba7d92c870b2daa1">recordStagingBufferMemoryBarrier</a> (const vk::CommandBuffer &amp;commandBuffer, vk::AccessFlagBits srcAccessMask, vk::AccessFlagBits dstAccessMask, vk::PipelineStageFlagBits srcStageMask, vk::PipelineStageFlagBits dstStageMask)</td></tr>
<tr class="separator:ae1c2ef6acb0b74dcba7d92c870b2daa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805e6050a935763488116e071c0ce461"><td class="memItemLeft" align="right" valign="top">vk::DescriptorBufferInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a805e6050a935763488116e071c0ce461">constructDescriptorBufferInfo</a> ()</td></tr>
<tr class="separator:a805e6050a935763488116e071c0ce461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb937df6cc482c1f37c74d8fab0f9a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a1fb937df6cc482c1f37c74d8fab0f9a9">size</a> ()</td></tr>
<tr class="separator:a1fb937df6cc482c1f37c74d8fab0f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47634859d03a074e27084589e5c0511d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a47634859d03a074e27084589e5c0511d">dataTypeMemorySize</a> ()</td></tr>
<tr class="separator:a47634859d03a074e27084589e5c0511d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be971eaffcb3192c46c6e49a3fe2773"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a4be971eaffcb3192c46c6e49a3fe2773">memorySize</a> ()</td></tr>
<tr class="separator:a4be971eaffcb3192c46c6e49a3fe2773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4addb015014f14da3d6019400c9771e4"><td class="memItemLeft" align="right" valign="top">TensorDataTypes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a4addb015014f14da3d6019400c9771e4">dataType</a> ()</td></tr>
<tr class="separator:a4addb015014f14da3d6019400c9771e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f554cac913805efb542243fcc94d252"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a3f554cac913805efb542243fcc94d252">rawData</a> ()</td></tr>
<tr class="separator:a3f554cac913805efb542243fcc94d252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b8a0e812aa2746726052c4bfa7307e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a70b8a0e812aa2746726052c4bfa7307e">setRawData</a> (const void *<a class="el" href="classkp_1_1Tensor.html#af4c8d1bdeb1e057bd0d1aea1207bc98e">data</a>)</td></tr>
<tr class="separator:a70b8a0e812aa2746726052c4bfa7307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c8d1bdeb1e057bd0d1aea1207bc98e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4c8d1bdeb1e057bd0d1aea1207bc98e"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#af4c8d1bdeb1e057bd0d1aea1207bc98e">data</a> ()</td></tr>
<tr class="separator:af4c8d1bdeb1e057bd0d1aea1207bc98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f59eceb0e7440501e11e1c8af598e84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f59eceb0e7440501e11e1c8af598e84"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a0f59eceb0e7440501e11e1c8af598e84">vector</a> ()</td></tr>
<tr class="separator:a0f59eceb0e7440501e11e1c8af598e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab48b2cb19e737a6f9e3bc2518b7b507c"><td class="memItemLeft" align="right" valign="top"><a id="ab48b2cb19e737a6f9e3bc2518b7b507c"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (TensorDataTypes dt)</td></tr>
<tr class="separator:ab48b2cb19e737a6f9e3bc2518b7b507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4feaf8cb3226e20812733830166bb6"><td class="memItemLeft" align="right" valign="top"><a id="a3d4feaf8cb3226e20812733830166bb6"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> dt)</td></tr>
<tr class="separator:a3d4feaf8cb3226e20812733830166bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adb314877043b92b0aefb60d394608d6f"><td class="memItemLeft" align="right" valign="top"><a id="adb314877043b92b0aefb60d394608d6f"></a>
<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mTensorType</b></td></tr>
<tr class="separator:adb314877043b92b0aefb60d394608d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb855bcbcf07453dae4a211bdebd4276"><td class="memItemLeft" align="right" valign="top"><a id="afb855bcbcf07453dae4a211bdebd4276"></a>
TensorDataTypes&#160;</td><td class="memItemRight" valign="bottom"><b>mDataType</b></td></tr>
<tr class="separator:afb855bcbcf07453dae4a211bdebd4276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af759d40f29dfdcc1e44a9cb839380fcc"><td class="memItemLeft" align="right" valign="top"><a id="af759d40f29dfdcc1e44a9cb839380fcc"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>mSize</b></td></tr>
<tr class="separator:af759d40f29dfdcc1e44a9cb839380fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22de8c7b3f3bb746a85a527a110d8f83"><td class="memItemLeft" align="right" valign="top"><a id="a22de8c7b3f3bb746a85a527a110d8f83"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>mDataTypeMemorySize</b></td></tr>
<tr class="separator:a22de8c7b3f3bb746a85a527a110d8f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c72d8305b33842b276a3d53df3b976d"><td class="memItemLeft" align="right" valign="top"><a id="a8c72d8305b33842b276a3d53df3b976d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>mRawData</b></td></tr>
<tr class="separator:a8c72d8305b33842b276a3d53df3b976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structured data used in GPU operations.</p>
<p>Tensors are the base building block in Kompute to perform operations across GPUs. Each tensor would have a respective Vulkan memory and buffer, which would be used to store their respective data. The tensors can be used for GPU data storage or transfer. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1b2af1c0e8dc0f154e11780e7103beb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2af1c0e8dc0f154e11780e7103beb4">&#9670;&nbsp;</a></span>TensorTypes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">kp::Tensor::TensorTypes</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type for tensors created: Device allows memory to be transferred from staging buffers. Staging are host memory visible. Storage are device visible but are not set up to transfer or receive data (only for shader storage). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f"></a>eDevice&#160;</td><td class="fielddoc"><p>Type is device memory, source and destination. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b2af1c0e8dc0f154e11780e7103beb4a746241fcf54388332f43a13dd4a82f0a"></a>eHost&#160;</td><td class="fielddoc"><p>Type is host memory, source and destination. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b2af1c0e8dc0f154e11780e7103beb4ae1a7e733531f08074becd467959f0521"></a>eStorage&#160;</td><td class="fielddoc"><p>Type is Device memory (only) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acfce13e44a6ab46d7ebf6618b09bcd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfce13e44a6ab46d7ebf6618b09bcd14">&#9670;&nbsp;</a></span>Tensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kp::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; vk::PhysicalDevice &gt;&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; vk::Device &gt;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elementTotalCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elementMemorySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorDataTypes &amp;&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> &amp;&#160;</td>
          <td class="paramname"><em>tensorType</em> = <code><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor with data provided which would be used to create the respective vulkan buffer and memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physicalDevice</td><td>The physical device to use to fetch properties </td></tr>
    <tr><td class="paramname">device</td><td>The device to use to create the buffer and memory from </td></tr>
    <tr><td class="paramname">data</td><td>Non-zero-sized vector of data that will be used by the tensor </td></tr>
    <tr><td class="paramname">tensorTypes</td><td>Type for the tensor which is of type TensorTypes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab71ac92ecaac55d9bcc75f1571bfd47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71ac92ecaac55d9bcc75f1571bfd47f">&#9670;&nbsp;</a></span>~Tensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kp::Tensor::~Tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor which is in charge of freeing vulkan resources unless they have been provided externally. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a805e6050a935763488116e071c0ce461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805e6050a935763488116e071c0ce461">&#9670;&nbsp;</a></span>constructDescriptorBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vk::DescriptorBufferInfo kp::Tensor::constructDescriptorBufferInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a vulkan descriptor buffer info which can be used to specify and reference the underlying buffer component of the tensor without exposing it.</p>
<dl class="section return"><dt>Returns</dt><dd>Descriptor buffer info with own buffer </dd></dl>

</div>
</div>
<a id="af4c8d1bdeb1e057bd0d1aea1207bc98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c8d1bdeb1e057bd0d1aea1207bc98e">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* kp::Tensor::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template to return the pointer data converted by specific type, which would be any of the supported types including float, double, int32, uint32 and bool.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to raw memory containing raw bytes data of <a class="el" href="classkp_1_1Tensor.html">Tensor</a>. </dd></dl>

</div>
</div>
<a id="a4addb015014f14da3d6019400c9771e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4addb015014f14da3d6019400c9771e4">&#9670;&nbsp;</a></span>dataType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TensorDataTypes kp::Tensor::dataType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the data type of the tensor (host, device, storage)</p>
<dl class="section return"><dt>Returns</dt><dd>Data type of tensor of type kp::Tensor::TensorDataTypes </dd></dl>

</div>
</div>
<a id="a47634859d03a074e27084589e5c0511d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47634859d03a074e27084589e5c0511d">&#9670;&nbsp;</a></span>dataTypeMemorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t kp::Tensor::dataTypeMemorySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total size of a single element of the respective data type that this tensor holds.</p>
<dl class="section return"><dt>Returns</dt><dd>Unsigned integer representing the memory of a single element of the respective data type. </dd></dl>

</div>
</div>
<a id="a5cdbcb7abaad8f3e3a392741ea5ad275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdbcb7abaad8f3e3a392741ea5ad275">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys and frees the GPU resources which include the buffer and memory. </p>

</div>
</div>
<a id="af2ae7f0b57fd8e57570ab63962a97f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ae7f0b57fd8e57570ab63962a97f36">&#9670;&nbsp;</a></span>isInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kp::Tensor::isInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether tensor is initialized based on the created gpu resources.</p>
<dl class="section return"><dt>Returns</dt><dd>Boolean stating whether tensor is initialized </dd></dl>

</div>
</div>
<a id="a4be971eaffcb3192c46c6e49a3fe2773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be971eaffcb3192c46c6e49a3fe2773">&#9670;&nbsp;</a></span>memorySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t kp::Tensor::memorySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total memory size of the data contained by the <a class="el" href="classkp_1_1Tensor.html">Tensor</a> object which would equate to (this-&gt;<a class="el" href="classkp_1_1Tensor.html#a1fb937df6cc482c1f37c74d8fab0f9a9">size()</a> * this-&gt;<a class="el" href="classkp_1_1Tensor.html#a47634859d03a074e27084589e5c0511d">dataTypeMemorySize()</a>)</p>
<dl class="section return"><dt>Returns</dt><dd>Unsigned integer representing the memory of a single element of the respective data type. </dd></dl>

</div>
</div>
<a id="a3f554cac913805efb542243fcc94d252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f554cac913805efb542243fcc94d252">&#9670;&nbsp;</a></span>rawData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* kp::Tensor::rawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the raw data via the pointer to the memory that contains the raw memory of this current tensor. This tensor gets changed to a nullptr when the <a class="el" href="classkp_1_1Tensor.html">Tensor</a> is removed.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to raw memory containing raw bytes data of <a class="el" href="classkp_1_1Tensor.html">Tensor</a>. </dd></dl>

</div>
</div>
<a id="aece585e97c20ed7133fdfe9fabed9bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece585e97c20ed7133fdfe9fabed9bd6">&#9670;&nbsp;</a></span>rebuild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::rebuild </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elementTotalCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elementMemorySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to trigger reinitialisation of the tensor buffer and memory with new data as well as new potential device type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Vector of data to use to initialise vector from </td></tr>
    <tr><td class="paramname">tensorType</td><td>The type to use for the tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe8b7b81913863523c7a3e580cf91d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8b7b81913863523c7a3e580cf91d8e">&#9670;&nbsp;</a></span>recordCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classkp_1_1Tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>copyFromTensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records a copy from the memory of the tensor provided to the current thensor. This is intended to pass memory into a processing, to perform a staging buffer transfer, or to gather output (between others).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
    <tr><td class="paramname">copyFromTensor</td><td><a class="el" href="classkp_1_1Tensor.html">Tensor</a> to copy the data from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4be54f0063ffc1687006d6f0b417fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4be54f0063ffc1687006d6f0b417fcb">&#9670;&nbsp;</a></span>recordCopyFromDeviceToStaging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordCopyFromDeviceToStaging </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records a copy from the internal device memory to the staging memory using an optional barrier to wait for the operation. This function would only be relevant for kp::Tensors of type eDevice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac565adf645121120c0b9ec31c04c743b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac565adf645121120c0b9ec31c04c743b">&#9670;&nbsp;</a></span>recordCopyFromStagingToDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordCopyFromStagingToDevice </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records a copy from the internal staging memory to the device memory using an optional barrier to wait for the operation. This function would only be relevant for kp::Tensors of type eDevice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bacad91d866079585f18feb3ec6d8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bacad91d866079585f18feb3ec6d8f7">&#9670;&nbsp;</a></span>recordPrimaryBufferMemoryBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordPrimaryBufferMemoryBarrier </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::AccessFlagBits&#160;</td>
          <td class="paramname"><em>srcAccessMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::AccessFlagBits&#160;</td>
          <td class="paramname"><em>dstAccessMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::PipelineStageFlagBits&#160;</td>
          <td class="paramname"><em>srcStageMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::PipelineStageFlagBits&#160;</td>
          <td class="paramname"><em>dstStageMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records the buffer memory barrier into the primary buffer and command buffer which ensures that relevant data transfers are carried out correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
    <tr><td class="paramname">srcAccessMask</td><td>Access flags for source access mask </td></tr>
    <tr><td class="paramname">dstAccessMask</td><td>Access flags for destination access mask </td></tr>
    <tr><td class="paramname">scrStageMask</td><td>Pipeline stage flags for source stage mask </td></tr>
    <tr><td class="paramname">dstStageMask</td><td>Pipeline stage flags for destination stage mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1c2ef6acb0b74dcba7d92c870b2daa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c2ef6acb0b74dcba7d92c870b2daa1">&#9670;&nbsp;</a></span>recordStagingBufferMemoryBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordStagingBufferMemoryBarrier </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::AccessFlagBits&#160;</td>
          <td class="paramname"><em>srcAccessMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::AccessFlagBits&#160;</td>
          <td class="paramname"><em>dstAccessMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::PipelineStageFlagBits&#160;</td>
          <td class="paramname"><em>srcStageMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::PipelineStageFlagBits&#160;</td>
          <td class="paramname"><em>dstStageMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records the buffer memory barrier into the staging buffer and command buffer which ensures that relevant data transfers are carried out correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
    <tr><td class="paramname">srcAccessMask</td><td>Access flags for source access mask </td></tr>
    <tr><td class="paramname">dstAccessMask</td><td>Access flags for destination access mask </td></tr>
    <tr><td class="paramname">scrStageMask</td><td>Pipeline stage flags for source stage mask </td></tr>
    <tr><td class="paramname">dstStageMask</td><td>Pipeline stage flags for destination stage mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b8a0e812aa2746726052c4bfa7307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b8a0e812aa2746726052c4bfa7307e">&#9670;&nbsp;</a></span>setRawData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::setRawData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets / resets the data of the tensor which is directly done on the GPU host visible memory available by the tensor. </p>

</div>
</div>
<a id="a1fb937df6cc482c1f37c74d8fab0f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb937df6cc482c1f37c74d8fab0f9a9">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t kp::Tensor::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size/magnitude of the <a class="el" href="classkp_1_1Tensor.html">Tensor</a>, which will be the total number of elements across all dimensions</p>
<dl class="section return"><dt>Returns</dt><dd>Unsigned integer representing the total number of elements </dd></dl>

</div>
</div>
<a id="a59452f1c62fd738536bb0a6cbf8d896b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59452f1c62fd738536bb0a6cbf8d896b">&#9670;&nbsp;</a></span>tensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> kp::Tensor::tensorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the tensor type of the <a class="el" href="classkp_1_1Tensor.html">Tensor</a></p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classkp_1_1Tensor.html">Tensor</a> type of tensor </dd></dl>

</div>
</div>
<a id="a0f59eceb0e7440501e11e1c8af598e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f59eceb0e7440501e11e1c8af598e84">&#9670;&nbsp;</a></span>vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; kp::Tensor::vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Template to get the data of the current tensor as a vector of specific type, which would be any of the supported types including float, double, int32, uint32 and bool.</p>
<dl class="section return"><dt>Returns</dt><dd>Vector of type provided by template. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/alejandro/Programming/kubernetes/seldon/vulkan-kompute/src/include/kompute/<a class="el" href="Tensor_8hpp_source.html">Tensor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
