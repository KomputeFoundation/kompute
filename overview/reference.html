
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../_static/javascripts/modernizr.js"></script>
  
  <script>
      window.ga = window.ga || function () {
          (ga.q = ga.q || []).push(arguments)
      };
      ga.l = +new Date;
      ga('create', 'G-F9LD9HL8LW', 'auto');
      ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  
  
    <title>Class Documentation and C++ Reference &#8212; Kompute Documentation (Python &amp; C++)</title>
    <link rel="stylesheet" href="../_static/material.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/assets/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Python Package Overview" href="python-package.html" />
    <link rel="prev" title="Extending Kompute with Custom C++ Operations" href="custom-operations.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=red data-md-color-accent=light-blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#overview/reference" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../index.html" title="Kompute Documentation (Python &amp; C++)"
           class="md-header-nav__button md-logo">
          
            &nbsp;
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">Kompute Documentation (Python & C++)</span>
          <span class="md-header-nav__topic"> Class Documentation and C++ Reference </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/KomputeProject/kompute/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Kompute
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../"versions.json"",
        target_loc = "../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../index.html" class="md-tabs__link">Kompute Documentation (Python & C++)</a></li>
            
            <li class="md-tabs__item"><a href="https://github.com/KomputeProject/kompute/" class="md-tabs__link">Kompute Repo</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../index.html" title="Kompute Documentation (Python &amp; C++)" class="md-nav__button md-logo">
      
        <img src="../_static/" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../index.html"
       title="Kompute Documentation (Python &amp; C++)">Kompute Documentation (Python & C++)</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/KomputeProject/kompute/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Kompute
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">C++ Documentation:</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="https://kompute.cc/" class="md-nav__link">Documentation Home</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="community.html" class="md-nav__link">Community Meetings, Discord & Links</a>
      
    
    </li>
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">C++ Documentation:</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="advanced-examples.html" class="md-nav__link">C++ Examples</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="memory-management.html" class="md-nav__link">Memory Management Principles</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="build-system.html" class="md-nav__link">Build System Deep Dive</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="shaders-to-headers.html" class="md-nav__link">Processing Shaders (Online & Offline)</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="custom-operations.html" class="md-nav__link">Extending Kompute with Custom Operations</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    <label class="md-nav__link md-nav__link--active" for="__toc"> C++ Class Documentation & Reference </label>
    
      <a href="#" class="md-nav__link md-nav__link--active">C++ Class Documentation & Reference</a>
      
        
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#overview-reference--page-root" class="md-nav__link">Class Documentation and C++ Reference</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#manager" class="md-nav__link">Manager</a>
        </li>
        <li class="md-nav__item"><a href="#sequence" class="md-nav__link">Sequence</a>
        </li>
        <li class="md-nav__item"><a href="#tensor" class="md-nav__link">Tensor</a>
        </li>
        <li class="md-nav__item"><a href="#algorithm" class="md-nav__link">Algorithm</a>
        </li>
        <li class="md-nav__item"><a href="#opbase" class="md-nav__link">OpBase</a>
        </li>
        <li class="md-nav__item"><a href="#opalgodispatch" class="md-nav__link">OpAlgoDispatch</a>
        </li>
        <li class="md-nav__item"><a href="#opmult" class="md-nav__link">OpMult</a>
        </li>
        <li class="md-nav__item"><a href="#optensorcopy" class="md-nav__link">OpTensorCopy</a>
        </li>
        <li class="md-nav__item"><a href="#optensorsynclocal" class="md-nav__link">OpTensorSyncLocal</a>
        </li>
        <li class="md-nav__item"><a href="#optensorsyncdevice" class="md-nav__link">OpTensorSyncDevice</a>
        </li>
        <li class="md-nav__item"><a href="#opmemorybarrier" class="md-nav__link">OpMemoryBarrier</a>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../_sources/overview/reference.rst.txt">Show Source</a> </li>

  </ul>
</nav>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="https://kompute.cc/codecov/" class="md-nav__link">Test Code Coverage</a>
      
    
    </li>
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">Python Documentation:</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="python-package.html" class="md-nav__link">Python Package Overview</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="python-reference.html" class="md-nav__link">Python Class Documentation & Reference</a>
      
    
    </li>
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">Examples:</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="python-examples.html" class="md-nav__link">Python Examples</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="advanced-examples.html" class="md-nav__link">C++ Examples</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="mobile-android.html" class="md-nav__link">Android Mobile App Integration</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="raspberry-pi.html" class="md-nav__link">Edge Device Raspberry Pi Mesa Drivers</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="game-engine-godot.html" class="md-nav__link">Game Engine Godot Integration</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="matmul-benchmark.html" class="md-nav__link">Example Benchmark with Matrix Multiplication</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="convolutional-net.html" class="md-nav__link">Convolutional Neural Network (CNN) Simple Upscale</a>
      
    
    </li>
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">Advanced Concepts &amp; Deep Dives:</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="ci-tests.html" class="md-nav__link">CI, Docker Images Docs & Tests</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="variable-types.html" class="md-nav__link">Variable Types for Tensors, and Push/Spec Constants</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="async-parallel.html" class="md-nav__link">Asynchronous & Parallel Operations</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../genindex.html" class="md-nav__link">Code Index</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#overview-reference--page-root" class="md-nav__link">Class Documentation and C++ Reference</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#manager" class="md-nav__link">Manager</a>
        </li>
        <li class="md-nav__item"><a href="#sequence" class="md-nav__link">Sequence</a>
        </li>
        <li class="md-nav__item"><a href="#tensor" class="md-nav__link">Tensor</a>
        </li>
        <li class="md-nav__item"><a href="#algorithm" class="md-nav__link">Algorithm</a>
        </li>
        <li class="md-nav__item"><a href="#opbase" class="md-nav__link">OpBase</a>
        </li>
        <li class="md-nav__item"><a href="#opalgodispatch" class="md-nav__link">OpAlgoDispatch</a>
        </li>
        <li class="md-nav__item"><a href="#opmult" class="md-nav__link">OpMult</a>
        </li>
        <li class="md-nav__item"><a href="#optensorcopy" class="md-nav__link">OpTensorCopy</a>
        </li>
        <li class="md-nav__item"><a href="#optensorsynclocal" class="md-nav__link">OpTensorSyncLocal</a>
        </li>
        <li class="md-nav__item"><a href="#optensorsyncdevice" class="md-nav__link">OpTensorSyncDevice</a>
        </li>
        <li class="md-nav__item"><a href="#opmemorybarrier" class="md-nav__link">OpMemoryBarrier</a>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../_sources/overview/reference.rst.txt">Show Source</a> </li>

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <section id="class-documentation-and-c-reference">
<h1 id="overview-reference--page-root">Class Documentation and C++ Reference<a class="headerlink" href="#overview-reference--page-root" title="Permalink to this headline">¶</a></h1>
<p>This section provides a breakdown of the cpp classes and what each of their functions provide. It is partially generated and augomented from the Doxygen autodoc content. You can also go directly to the <a class="reference external" href="../doxygen/annotated.html">raw doxygen docs</a>.</p>
<p>Below is a diagram that provides insights on the relationship between Kompute objects and Vulkan SDK resources, which primarily encompass ownership of either CPU and/or GPU memory.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture.jpg"><img alt="../_images/kompute-vulkan-architecture.jpg" src="../_images/kompute-vulkan-architecture.jpg" style="width: 100%;"/></a>
<section id="manager">
<h2 id="manager">Manager<a class="headerlink" href="#manager" title="Permalink to this headline">¶</a></h2>
<p>The Kompute Manager provides a high level interface to simplify interaction with underlying <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::Sequences</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::Operations</span></code>.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-manager.jpg"><img alt="../_images/kompute-vulkan-architecture-manager.jpg" src="../_images/kompute-vulkan-architecture-manager.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp7ManagerE">
<span id="_CPPv3N2kp7ManagerE"></span><span id="_CPPv2N2kp7ManagerE"></span><span id="kp::Manager"></span><span class="target" id="classkp_1_1Manager"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Manager</code><a class="headerlink" href="#_CPPv4N2kp7ManagerE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base orchestrator which creates and manages device and child components </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager7ManagerEv">
<span id="_CPPv3N2kp7Manager7ManagerEv"></span><span id="_CPPv2N2kp7Manager7ManagerEv"></span><span id="kp::Manager::Manager"></span><span class="target" id="classkp_1_1Manager_1a43cc11ff353b2b0775e6a204c8395d97"></span><code class="sig-name descname">Manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager7ManagerEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base constructor and default used which creates the base resources including choosing the device 0 by default. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager7ManagerE8uint32_tRKNSt6vectorI8uint32_tEERKNSt6vectorINSt6stringEEE">
<span id="_CPPv3N2kp7Manager7ManagerE8uint32_tRKNSt6vectorI8uint32_tEERKNSt6vectorINSt6stringEEE"></span><span id="_CPPv2N2kp7Manager7ManagerE8uint32_tRKNSt6vectorI8uint32_tEERKNSt6vectorINSt6stringEEE"></span><span id="kp::Manager::Manager__uint32_t.std::vector:uint32_t:CR.std::vector:ss:CR"></span><span class="target" id="classkp_1_1Manager_1a03870694ea0749424dc5206638b29c32"></span><code class="sig-name descname">Manager</code><span class="sig-paren">(</span>uint32_t <em>physicalDeviceIndex</em>, <em class="property">const</em> std::vector&lt;uint32_t&gt; &amp;<em>familyQueueIndices</em> = {}, <em class="property">const</em> std::vector&lt;std::string&gt; &amp;<em>desiredExtensions</em> = {}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager7ManagerE8uint32_tRKNSt6vectorI8uint32_tEERKNSt6vectorINSt6stringEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Similar to base constructor but allows for further configuration to use when creating the Vulkan resources.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDeviceIndex</span></code>: The index of the physical device to use </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">familyQueueIndices</span></code>: (Optional) List of queue indices to add for explicit allocation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">desiredExtensions</span></code>: The desired extensions to load from physicalDevice </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager7ManagerENSt10shared_ptrIN2vk8InstanceEEENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE">
<span id="_CPPv3N2kp7Manager7ManagerENSt10shared_ptrIN2vk8InstanceEEENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE"></span><span id="_CPPv2N2kp7Manager7ManagerENSt10shared_ptrIN2vk8InstanceEEENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE"></span><span id="kp::Manager::Manager__std::shared_ptr:vk::Instance:.std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:"></span><span class="target" id="classkp_1_1Manager_1afe401feb6eeb8d462998f095d36e2b46"></span><code class="sig-name descname">Manager</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::Instance&gt; <em>instance</em>, std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager7ManagerENSt10shared_ptrIN2vk8InstanceEEENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p><a class="reference internal" href="#classkp_1_1Manager"><span class="std std-ref">Manager</span></a> constructor which allows your own vulkan application to integrate with the kompute use.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span></code>: Vulkan compute instance to base this application </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device to use for application </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device to use for all base resources </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDeviceIndex</span></code>: Index for vulkan physical device used </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7ManagerD0Ev">
<span id="_CPPv3N2kp7ManagerD0Ev"></span><span id="_CPPv2N2kp7ManagerD0Ev"></span><span id="kp::Manager::~Manager"></span><span class="target" id="classkp_1_1Manager_1af9b31d91851f8b7bb8d95c32a905b1ad"></span><code class="sig-name descname">~Manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7ManagerD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p><a class="reference internal" href="#classkp_1_1Manager"><span class="std std-ref">Manager</span></a> destructor which would ensure all owned resources are destroyed unless explicitly stated that resources should not be destroyed or freed. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager8sequenceE8uint32_t8uint32_t">
<span id="_CPPv3N2kp7Manager8sequenceE8uint32_t8uint32_t"></span><span id="_CPPv2N2kp7Manager8sequenceE8uint32_t8uint32_t"></span><span id="kp::Manager::sequence__uint32_t.uint32_t"></span><span class="target" id="classkp_1_1Manager_1a5fac648ac65d2e1314120ebf6f91de91"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">sequence</code><span class="sig-paren">(</span>uint32_t <em>queueIndex</em> = 0, uint32_t <em>totalTimestamps</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager8sequenceE8uint32_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Create a managed sequence that will be destroyed by this manager if it hasn’t been destroyed by its reference count going to zero.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Shared pointer with initialised sequence </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">queueIndex</span></code>: The queue to use from the available queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nrOfTimestamps</span></code>: The maximum number of timestamps to allocate. If zero (default), disables latching of timestamps. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0EN2kp7Manager7tensorTENSt10shared_ptrI7TensorTI1TEEERKNSt6vectorI1TEEN6Tensor11TensorTypesE">
<span id="_CPPv3I0EN2kp7Manager7tensorTERKNSt6vectorI1TEEN6Tensor11TensorTypesE"></span><span id="_CPPv2I0EN2kp7Manager7tensorTERKNSt6vectorI1TEEN6Tensor11TensorTypesE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br/><span class="target" id="classkp_1_1Manager_1ad48ebcd90c1f1cec859d7c9092279570"></span>std::shared_ptr&lt;TensorT&lt;<a class="reference internal" href="#_CPPv4I0EN2kp7Manager7tensorTENSt10shared_ptrI7TensorTI1TEEERKNSt6vectorI1TEEN6Tensor11TensorTypesE" title="kp::Manager::tensorT::T">T</a>&gt;&gt; <code class="sig-name descname">tensorT</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I0EN2kp7Manager7tensorTENSt10shared_ptrI7TensorTI1TEEERKNSt6vectorI1TEEN6Tensor11TensorTypesE" title="kp::Manager::tensorT::T">T</a>&gt; &amp;<em>data</em>, <a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>::<a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a> <em>tensorType</em> = <a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>::<a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a>::<a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypes7eDeviceE" title="kp::Tensor::TensorTypes::eDevice">eDevice</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN2kp7Manager7tensorTENSt10shared_ptrI7TensorTI1TEEERKNSt6vectorI1TEEN6Tensor11TensorTypesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Create a managed tensor that will be destroyed by this manager if it hasn’t been destroyed by its reference count going to zero.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Shared pointer with initialised tensor </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: The data to initialize the tensor with </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensorType</span></code>: The type of tensor to initialize </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager9algorithmERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorIfEERKNSt6vectorIfEE">
<span id="_CPPv3N2kp7Manager9algorithmERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorIfEERKNSt6vectorIfEE"></span><span id="_CPPv2N2kp7Manager9algorithmERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorIfEERKNSt6vectorIfEE"></span><span id="kp::Manager::algorithm__std::vector:std::shared_ptr:Tensor::CR.std::vector:uint32_t:CR.WorkgroupCR.std::vector:float:CR.std::vector:float:CR"></span><span class="target" id="classkp_1_1Manager_1a995c89ff0d4a57acd69fe25ecd301518"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp9AlgorithmE" title="kp::Algorithm">Algorithm</a>&gt; <code class="sig-name descname">algorithm</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em> = {}, <em class="property">const</em> std::vector&lt;uint32_t&gt; &amp;<em>spirv</em> = {}, <em class="property">const</em> Workgroup &amp;<em>workgroup</em> = {}, <em class="property">const</em> std::vector&lt;float&gt; &amp;<em>specializationConstants</em> = {}, <em class="property">const</em> std::vector&lt;float&gt; &amp;<em>pushConstants</em> = {}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager9algorithmERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorIfEERKNSt6vectorIfEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default non-template function that can be used to create algorithm objects which provides default types to the push and spec constants as floats.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Shared pointer with initialised algorithm </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: (optional) The tensors to initialise the algorithm with </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spirv</span></code>: (optional) The SPIRV bytes for the algorithm to dispatch </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code>: (optional) kp::Workgroup for algorithm to use, and defaults to (tensor[0].size(), 1, 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">specializationConstants</span></code>: (optional) float vector to use for specialization constants, and defaults to an empty constant </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pushConstants</span></code>: (optional) float vector to use for push constants, and defaults to an empty constant </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I00EN2kp7Manager9algorithmENSt10shared_ptrI9AlgorithmEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE">
<span id="_CPPv3I00EN2kp7Manager9algorithmERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE"></span><span id="_CPPv2I00EN2kp7Manager9algorithmERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE"></span>template&lt;typename <code class="sig-name descname">S</code> = float, typename <code class="sig-name descname">P</code> = float&gt;<br/><span class="target" id="classkp_1_1Manager_1a008f47f9f64cc9bf11f90cdab735b831"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp9AlgorithmE" title="kp::Algorithm">Algorithm</a>&gt; <code class="sig-name descname">algorithm</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em>, <em class="property">const</em> std::vector&lt;uint32_t&gt; &amp;<em>spirv</em>, <em class="property">const</em> Workgroup &amp;<em>workgroup</em>, <em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I00EN2kp7Manager9algorithmENSt10shared_ptrI9AlgorithmEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE" title="kp::Manager::algorithm::S">S</a>&gt; &amp;<em>specializationConstants</em>, <em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I00EN2kp7Manager9algorithmENSt10shared_ptrI9AlgorithmEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE" title="kp::Manager::algorithm::P">P</a>&gt; &amp;<em>pushConstants</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN2kp7Manager9algorithmENSt10shared_ptrI9AlgorithmEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Create a managed algorithm that will be destroyed by this manager if it hasn’t been destroyed by its reference count going to zero.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Shared pointer with initialised algorithm </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: (optional) The tensors to initialise the algorithm with </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spirv</span></code>: (optional) The SPIRV bytes for the algorithm to dispatch </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code>: (optional) kp::Workgroup for algorithm to use, and defaults to (tensor[0].size(), 1, 1) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">specializationConstants</span></code>: (optional) templatable vector parameter to use for specialization constants, and defaults to an empty constant </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pushConstants</span></code>: (optional) templatable vector parameter to use for push constants, and defaults to an empty constant </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager7destroyEv">
<span id="_CPPv3N2kp7Manager7destroyEv"></span><span id="_CPPv2N2kp7Manager7destroyEv"></span><span id="kp::Manager::destroy"></span><span class="target" id="classkp_1_1Manager_1a69ab19202bee0c3e0c4f96f9abd6dcc8"></span>void <code class="sig-name descname">destroy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager7destroyEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destroy the GPU resources and all managed resources by manager. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager5clearEv">
<span id="_CPPv3N2kp7Manager5clearEv"></span><span id="_CPPv2N2kp7Manager5clearEv"></span><span id="kp::Manager::clear"></span><span class="target" id="classkp_1_1Manager_1a88bae28eafe571f204a29803f712a0f1"></span>void <code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager5clearEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Run a pseudo-garbage collection to release all the managed resources that have been already freed due to these reaching to zero ref count. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4NK2kp7Manager19getDevicePropertiesEv">
<span id="_CPPv3NK2kp7Manager19getDevicePropertiesEv"></span><span id="_CPPv2NK2kp7Manager19getDevicePropertiesEv"></span><span id="kp::Manager::getDevicePropertiesC"></span><span class="target" id="classkp_1_1Manager_1a27f0c61059156fac4d1f81ee59f70a05"></span>vk::PhysicalDeviceProperties <code class="sig-name descname">getDeviceProperties</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK2kp7Manager19getDevicePropertiesEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Information about the current device.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>vk::PhysicalDeviceProperties containing information about the device </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4NK2kp7Manager11listDevicesEv">
<span id="_CPPv3NK2kp7Manager11listDevicesEv"></span><span id="_CPPv2NK2kp7Manager11listDevicesEv"></span><span id="kp::Manager::listDevicesC"></span><span class="target" id="classkp_1_1Manager_1a5aada58e5b79bc30be715f7df515064a"></span>std::vector&lt;vk::PhysicalDevice&gt; <code class="sig-name descname">listDevices</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK2kp7Manager11listDevicesEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>List the devices available in the current vulkan instance.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>vector of physical devices containing their respective properties </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4NK2kp7Manager13getVkInstanceEv">
<span id="_CPPv3NK2kp7Manager13getVkInstanceEv"></span><span id="_CPPv2NK2kp7Manager13getVkInstanceEv"></span><span id="kp::Manager::getVkInstanceC"></span><span class="target" id="classkp_1_1Manager_1a6d532bf051a16aaba2a07f6de8c789f4"></span>std::shared_ptr&lt;vk::Instance&gt; <code class="sig-name descname">getVkInstance</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK2kp7Manager13getVkInstanceEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>The current Vulkan instance.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>a shared pointer to the current Vulkan instance held by this object </p>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="sequence">
<h2 id="sequence">Sequence<a class="headerlink" href="#sequence" title="Permalink to this headline">¶</a></h2>
<p>The Kompute Sequence consists of batches of <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::Operations</span></code>, which are executed on a respective GPU queue. The execution of sequences can be synchronous or asynchronous, and it can be coordinated through its respective vk::Fence.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-sequence.jpg"><img alt="../_images/kompute-vulkan-architecture-sequence.jpg" src="../_images/kompute-vulkan-architecture-sequence.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp8SequenceE">
<span id="_CPPv3N2kp8SequenceE"></span><span id="_CPPv2N2kp8SequenceE"></span><span id="kp::Sequence"></span><span class="target" id="classkp_1_1Sequence"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Sequence</code> : <em class="property">public</em> std::enable_shared_from_this&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt;<a class="headerlink" href="#_CPPv4N2kp8SequenceE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Container of operations that can be sent to GPU as batch </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence8SequenceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk5QueueEEE8uint32_t8uint32_t">
<span id="_CPPv3N2kp8Sequence8SequenceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk5QueueEEE8uint32_t8uint32_t"></span><span id="_CPPv2N2kp8Sequence8SequenceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk5QueueEEE8uint32_t8uint32_t"></span><span id="kp::Sequence::Sequence__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::Queue:.uint32_t.uint32_t"></span><span class="target" id="classkp_1_1Sequence_1afb1974c612652d9c58b6e0bcfb83db4a"></span><code class="sig-name descname">Sequence</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::Queue&gt; <em>computeQueue</em>, uint32_t <em>queueIndex</em>, uint32_t <em>totalTimestamps</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence8SequenceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk5QueueEEE8uint32_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Main constructor for sequence which requires core vulkan components to generate all dependent resources.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">computeQueue</span></code>: Vulkan compute queue </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queueIndex</span></code>: Vulkan compute queue index in device </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">totalTimestamps</span></code>: Maximum number of timestamps to allocate </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8SequenceD0Ev">
<span id="_CPPv3N2kp8SequenceD0Ev"></span><span id="_CPPv2N2kp8SequenceD0Ev"></span><span id="kp::Sequence::~Sequence"></span><span class="target" id="classkp_1_1Sequence_1a657bf520b64ddbd42e12095c5241ef52"></span><code class="sig-name descname">~Sequence</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8SequenceD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destructor for sequence which is responsible for cleaning all subsequent owned operations. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence6recordENSt10shared_ptrI6OpBaseEE">
<span id="_CPPv3N2kp8Sequence6recordENSt10shared_ptrI6OpBaseEE"></span><span id="_CPPv2N2kp8Sequence6recordENSt10shared_ptrI6OpBaseEE"></span><span id="kp::Sequence::record__std::shared_ptr:OpBase:"></span><span class="target" id="classkp_1_1Sequence_1a8fb61022e531b4536210e8da262c297b"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">record</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a>&gt; <em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence6recordENSt10shared_ptrI6OpBaseEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Record function for operation to be added to the GPU queue in batch. This template requires classes to be derived from the <a class="reference internal" href="#classkp_1_1OpBase"><span class="std std-ref">OpBase</span></a> class. This function also requires the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> to be recording, otherwise it will not be able to add the operation.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">op</span></code>: Object derived from kp::BaseOp that will be recoreded by the sequence which will be used when the operation is evaluated. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp8Sequence6recordENSt10shared_ptrI8SequenceEENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp8Sequence6recordENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp8Sequence6recordENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Sequence_1a3876a3d62a5fa473f54b5402e714dfba"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">record</code><span class="sig-paren">(</span>std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp8Sequence6recordENSt10shared_ptrI8SequenceEENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="kp::Sequence::record::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp8Sequence6recordENSt10shared_ptrI8SequenceEENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Record function for operation to be added to the GPU queue in batch. This template requires classes to be derived from the <a class="reference internal" href="#classkp_1_1OpBase"><span class="std std-ref">OpBase</span></a> class. This function also requires the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> to be recording, otherwise it will not be able to add the operation.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Vector of tensors to use for the operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TArgs</span></code>: Template parameters that are used to initialise operation which allows for extensible configurations on initialisation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp8Sequence6recordENSt10shared_ptrI8SequenceEENSt10shared_ptrI9AlgorithmEEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp8Sequence6recordENSt10shared_ptrI9AlgorithmEEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp8Sequence6recordENSt10shared_ptrI9AlgorithmEEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Sequence_1a329ef5d6884b9e4990a605c7c09148cd"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">record</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp9AlgorithmE" title="kp::Algorithm">Algorithm</a>&gt; <em>algorithm</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp8Sequence6recordENSt10shared_ptrI8SequenceEENSt10shared_ptrI9AlgorithmEEDpRR5TArgs" title="kp::Sequence::record::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp8Sequence6recordENSt10shared_ptrI8SequenceEENSt10shared_ptrI9AlgorithmEEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Record function for operation to be added to the GPU queue in batch. This template requires classes to be derived from the <a class="reference internal" href="#classkp_1_1OpBase"><span class="std std-ref">OpBase</span></a> class. This function also requires the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> to be recording, otherwise it will not be able to add the operation.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code>: <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> to use for the record often used for OpAlgo operations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TArgs</span></code>: Template parameters that are used to initialise operation which allows for extensible configurations on initialisation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence4evalEv">
<span id="_CPPv3N2kp8Sequence4evalEv"></span><span id="_CPPv2N2kp8Sequence4evalEv"></span><span id="kp::Sequence::eval"></span><span class="target" id="classkp_1_1Sequence_1a68c5ba3aca4722f9fe5d2a18be861c22"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">eval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence4evalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval sends all the recorded and stored operations in the vector of operations into the gpu as a submit job synchronously (with a barrier).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence4evalENSt10shared_ptrI6OpBaseEE">
<span id="_CPPv3N2kp8Sequence4evalENSt10shared_ptrI6OpBaseEE"></span><span id="_CPPv2N2kp8Sequence4evalENSt10shared_ptrI6OpBaseEE"></span><span id="kp::Sequence::eval__std::shared_ptr:OpBase:"></span><span class="target" id="classkp_1_1Sequence_1a72174842726736dba0a7fafd364fef04"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">eval</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a>&gt; <em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence4evalENSt10shared_ptrI6OpBaseEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Resets all the recorded and stored operations, records the operation provided and submits into the gpu as a submit job synchronously (with a barrier).</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp8Sequence4evalENSt10shared_ptrI8SequenceEENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp8Sequence4evalENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp8Sequence4evalENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Sequence_1a71b1a4637647f3f26d2921f0e2f2d84e"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">eval</code><span class="sig-paren">(</span>std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp8Sequence4evalENSt10shared_ptrI8SequenceEENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="kp::Sequence::eval::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp8Sequence4evalENSt10shared_ptrI8SequenceEENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval sends all the recorded and stored operations in the vector of operations into the gpu as a submit job with a barrier.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Vector of tensors to use for the operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TArgs</span></code>: Template parameters that are used to initialise operation which allows for extensible configurations on initialisation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp8Sequence4evalENSt10shared_ptrI8SequenceEENSt10shared_ptrI9AlgorithmEEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp8Sequence4evalENSt10shared_ptrI9AlgorithmEEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp8Sequence4evalENSt10shared_ptrI9AlgorithmEEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Sequence_1a2491c91d9316b9d7c6bd20abd8099432"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">eval</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp9AlgorithmE" title="kp::Algorithm">Algorithm</a>&gt; <em>algorithm</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp8Sequence4evalENSt10shared_ptrI8SequenceEENSt10shared_ptrI9AlgorithmEEDpRR5TArgs" title="kp::Sequence::eval::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp8Sequence4evalENSt10shared_ptrI8SequenceEENSt10shared_ptrI9AlgorithmEEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval sends all the recorded and stored operations in the vector of operations into the gpu as a submit job with a barrier.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code>: <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> to use for the record often used for OpAlgo operations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TArgs</span></code>: Template parameters that are used to initialise operation which allows for extensible configurations on initialisation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence9evalAsyncEv">
<span id="_CPPv3N2kp8Sequence9evalAsyncEv"></span><span id="_CPPv2N2kp8Sequence9evalAsyncEv"></span><span id="kp::Sequence::evalAsync"></span><span class="target" id="classkp_1_1Sequence_1ad1e3b979160e5a535cb54026473936e6"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">evalAsync</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence9evalAsyncEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval Async sends all the recorded and stored operations in the vector of operations into the gpu as a submit job without a barrier. EvalAwait() must ALWAYS be called after to ensure the sequence is terminated correctly.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating whether execution was successful. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence9evalAsyncENSt10shared_ptrI6OpBaseEE">
<span id="_CPPv3N2kp8Sequence9evalAsyncENSt10shared_ptrI6OpBaseEE"></span><span id="_CPPv2N2kp8Sequence9evalAsyncENSt10shared_ptrI6OpBaseEE"></span><span id="kp::Sequence::evalAsync__std::shared_ptr:OpBase:"></span><span class="target" id="classkp_1_1Sequence_1a9ab8325fa620da4134a50de8b0b10a91"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">evalAsync</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a>&gt; <em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence9evalAsyncENSt10shared_ptrI6OpBaseEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Clears currnet operations to record provided one in the vector of operations into the gpu as a submit job without a barrier. EvalAwait() must ALWAYS be called after to ensure the sequence is terminated correctly.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating whether execution was successful. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp8Sequence9evalAsyncENSt10shared_ptrI8SequenceEENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp8Sequence9evalAsyncENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp8Sequence9evalAsyncENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Sequence_1a8139aa88d7bc6024bf15712fdc995710"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">evalAsync</code><span class="sig-paren">(</span>std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp8Sequence9evalAsyncENSt10shared_ptrI8SequenceEENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="kp::Sequence::evalAsync::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp8Sequence9evalAsyncENSt10shared_ptrI8SequenceEENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval sends all the recorded and stored operations in the vector of operations into the gpu as a submit job with a barrier.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Vector of tensors to use for the operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TArgs</span></code>: Template parameters that are used to initialise operation which allows for extensible configurations on initialisation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp8Sequence9evalAsyncENSt10shared_ptrI8SequenceEENSt10shared_ptrI9AlgorithmEEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp8Sequence9evalAsyncENSt10shared_ptrI9AlgorithmEEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp8Sequence9evalAsyncENSt10shared_ptrI9AlgorithmEEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Sequence_1a638f0e3646bcaab542cd2bdc5e1d00d7"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">evalAsync</code><span class="sig-paren">(</span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp9AlgorithmE" title="kp::Algorithm">Algorithm</a>&gt; <em>algorithm</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp8Sequence9evalAsyncENSt10shared_ptrI8SequenceEENSt10shared_ptrI9AlgorithmEEDpRR5TArgs" title="kp::Sequence::evalAsync::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp8Sequence9evalAsyncENSt10shared_ptrI8SequenceEENSt10shared_ptrI9AlgorithmEEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval sends all the recorded and stored operations in the vector of operations into the gpu as a submit job with a barrier.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code>: <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> to use for the record often used for OpAlgo operations </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TArgs</span></code>: Template parameters that are used to initialise operation which allows for extensible configurations on initialisation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence9evalAwaitE8uint64_t">
<span id="_CPPv3N2kp8Sequence9evalAwaitE8uint64_t"></span><span id="_CPPv2N2kp8Sequence9evalAwaitE8uint64_t"></span><span id="kp::Sequence::evalAwait__uint64_t"></span><span class="target" id="classkp_1_1Sequence_1a33766e097c3e392fe70f7e63bf258025"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">evalAwait</code><span class="sig-paren">(</span>uint64_t <em>waitFor</em> = UINT64_MAX<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence9evalAwaitE8uint64_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval Await waits for the fence to finish processing and then once it finishes, it runs the postEval of all operations.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>shared_ptr&lt;Sequence&gt; of the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> class itself </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">waitFor</span></code>: Number of milliseconds to wait before timing out. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence5clearEv">
<span id="_CPPv3N2kp8Sequence5clearEv"></span><span id="_CPPv2N2kp8Sequence5clearEv"></span><span id="kp::Sequence::clear"></span><span class="target" id="classkp_1_1Sequence_1a93e9693ac1a2f81ced4e3edb7a81e515"></span>void <code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence5clearEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Clear function clears all operations currently recorded and starts recording again. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence13getTimestampsEv">
<span id="_CPPv3N2kp8Sequence13getTimestampsEv"></span><span id="_CPPv2N2kp8Sequence13getTimestampsEv"></span><span id="kp::Sequence::getTimestamps"></span><span class="target" id="classkp_1_1Sequence_1a4b4e0b9a04695b9b936aa1e51468cccb"></span>std::vector&lt;std::uint64_t&gt; <code class="sig-name descname">getTimestamps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence13getTimestampsEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Return the timestamps that were latched at the beginning and after each operation during the last <a class="reference internal" href="#classkp_1_1Sequence_1a68c5ba3aca4722f9fe5d2a18be861c22"><span class="std std-ref">eval()</span></a> call. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence5beginEv">
<span id="_CPPv3N2kp8Sequence5beginEv"></span><span id="_CPPv2N2kp8Sequence5beginEv"></span><span id="kp::Sequence::begin"></span><span class="target" id="classkp_1_1Sequence_1aa5cda43db45350b31cd78b3f48226296"></span>void <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence5beginEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Begins recording commands for commands to be submitted into the command buffer. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence3endEv">
<span id="_CPPv3N2kp8Sequence3endEv"></span><span id="_CPPv2N2kp8Sequence3endEv"></span><span id="kp::Sequence::end"></span><span class="target" id="classkp_1_1Sequence_1a1a0be1b31a574c3265ab5fc071eab988"></span>void <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence3endEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Ends the recording and stops recording commands when the record command is sent. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4NK2kp8Sequence11isRecordingEv">
<span id="_CPPv3NK2kp8Sequence11isRecordingEv"></span><span id="_CPPv2NK2kp8Sequence11isRecordingEv"></span><span id="kp::Sequence::isRecordingC"></span><span class="target" id="classkp_1_1Sequence_1a022a4a79b72403c551a3a1851a620e36"></span>bool <code class="sig-name descname">isRecording</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK2kp8Sequence11isRecordingEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns true if the sequence is currently in recording activated.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating if recording ongoing. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4NK2kp8Sequence6isInitEv">
<span id="_CPPv3NK2kp8Sequence6isInitEv"></span><span id="_CPPv2NK2kp8Sequence6isInitEv"></span><span id="kp::Sequence::isInitC"></span><span class="target" id="classkp_1_1Sequence_1a7e1413fd082f00c56f0b058330fad23e"></span>bool <code class="sig-name descname">isInit</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK2kp8Sequence6isInitEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns true if the sequence has been initialised, and it’s based on the GPU resources being referenced.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating if is initialized </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence8rerecordEv">
<span id="_CPPv3N2kp8Sequence8rerecordEv"></span><span id="_CPPv2N2kp8Sequence8rerecordEv"></span><span id="kp::Sequence::rerecord"></span><span class="target" id="classkp_1_1Sequence_1a74fc63da146ea698e69f9177c5a0b456"></span>void <code class="sig-name descname">rerecord</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence8rerecordEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Clears command buffer and triggers re-record of all the current operations saved, which is useful if the underlying kp::Tensors or kp::Algorithms are modified and need to be re-recorded. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4NK2kp8Sequence9isRunningEv">
<span id="_CPPv3NK2kp8Sequence9isRunningEv"></span><span id="_CPPv2NK2kp8Sequence9isRunningEv"></span><span id="kp::Sequence::isRunningC"></span><span class="target" id="classkp_1_1Sequence_1a6fa5f0b72333920f9f105403d173ce37"></span>bool <code class="sig-name descname">isRunning</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK2kp8Sequence9isRunningEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns true if the sequence is currently running - mostly used for async workloads.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating if currently running. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence7destroyEv">
<span id="_CPPv3N2kp8Sequence7destroyEv"></span><span id="_CPPv2N2kp8Sequence7destroyEv"></span><span id="kp::Sequence::destroy"></span><span class="target" id="classkp_1_1Sequence_1afed7383026a663040ac85d310455b2aa"></span>void <code class="sig-name descname">destroy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence7destroyEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destroys and frees the GPU resources which include the buffer and memory and sets the sequence as init=False. </p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="tensor">
<h2 id="tensor">Tensor<a class="headerlink" href="#tensor" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::Tensor</span></code> is the atomic unit in Kompute, and it is used primarily for handling Host and GPU Device data.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-tensor.jpg"><img alt="../_images/kompute-vulkan-architecture-tensor.jpg" src="../_images/kompute-vulkan-architecture-tensor.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp6TensorE">
<span id="_CPPv3N2kp6TensorE"></span><span id="_CPPv2N2kp6TensorE"></span><span id="kp::Tensor"></span><span class="target" id="classkp_1_1Tensor"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Tensor</code><a class="headerlink" href="#_CPPv4N2kp6TensorE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Structured data used in GPU operations.</p>
<p>Tensors are the base building block in Kompute to perform operations across GPUs. Each tensor would have a respective Vulkan memory and buffer, which would be used to store their respective data. The tensors can be used for GPU data storage or transfer. </p>
<p>Subclassed by kp::TensorT&lt; T &gt;</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp enum">
<dt id="_CPPv4N2kp6Tensor11TensorTypesE">
<span id="_CPPv3N2kp6Tensor11TensorTypesE"></span><span id="_CPPv2N2kp6Tensor11TensorTypesE"></span><span class="target" id="classkp_1_1Tensor_1a1b2af1c0e8dc0f154e11780e7103beb4"></span><em class="property">enum </em><code class="sig-name descname">TensorTypes</code><a class="headerlink" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Type for tensors created: Device allows memory to be transferred from staging buffers. Staging are host memory visible. Storage are device visible but are not set up to transfer or receive data (only for shader storage). </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv4N2kp6Tensor11TensorTypes7eDeviceE">
<span id="_CPPv3N2kp6Tensor11TensorTypes7eDeviceE"></span><span id="_CPPv2N2kp6Tensor11TensorTypes7eDeviceE"></span><span class="target" id="classkp_1_1Tensor_1a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f"></span><em class="property">enumerator </em><code class="sig-name descname">eDevice</code> = 0<a class="headerlink" href="#_CPPv4N2kp6Tensor11TensorTypes7eDeviceE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Type is device memory, source and destination. </p>
</dd></dl>
<dl class="cpp enumerator">
<dt id="_CPPv4N2kp6Tensor11TensorTypes5eHostE">
<span id="_CPPv3N2kp6Tensor11TensorTypes5eHostE"></span><span id="_CPPv2N2kp6Tensor11TensorTypes5eHostE"></span><span class="target" id="classkp_1_1Tensor_1a1b2af1c0e8dc0f154e11780e7103beb4a746241fcf54388332f43a13dd4a82f0a"></span><em class="property">enumerator </em><code class="sig-name descname">eHost</code> = 1<a class="headerlink" href="#_CPPv4N2kp6Tensor11TensorTypes5eHostE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Type is host memory, source and destination. </p>
</dd></dl>
<dl class="cpp enumerator">
<dt id="_CPPv4N2kp6Tensor11TensorTypes8eStorageE">
<span id="_CPPv3N2kp6Tensor11TensorTypes8eStorageE"></span><span id="_CPPv2N2kp6Tensor11TensorTypes8eStorageE"></span><span class="target" id="classkp_1_1Tensor_1a1b2af1c0e8dc0f154e11780e7103beb4ae1a7e733531f08074becd467959f0521"></span><em class="property">enumerator </em><code class="sig-name descname">eStorage</code> = 2<a class="headerlink" href="#_CPPv4N2kp6Tensor11TensorTypes8eStorageE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Type is Device memory (only) </p>
</dd></dl>
</dd></dl>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor6TensorENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEEPv8uint32_t8uint32_tRK15TensorDataTypesRK11TensorTypes">
<span id="_CPPv3N2kp6Tensor6TensorENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEEPv8uint32_t8uint32_tRK15TensorDataTypesRK11TensorTypes"></span><span id="_CPPv2N2kp6Tensor6TensorENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEEPv8uint32_t8uint32_tRK15TensorDataTypesRK11TensorTypes"></span><span id="kp::Tensor::Tensor__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.voidP.uint32_t.uint32_t.TensorDataTypesCR.TensorTypesCR"></span><span class="target" id="classkp_1_1Tensor_1acfce13e44a6ab46d7ebf6618b09bcd14"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, void *<em>data</em>, uint32_t <em>elementTotalCount</em>, uint32_t <em>elementMemorySize</em>, <em class="property">const</em> TensorDataTypes &amp;<em>dataType</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a> &amp;<em>tensorType</em> = <a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a>::<a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypes7eDeviceE" title="kp::Tensor::TensorTypes::eDevice">eDevice</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor6TensorENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEEPv8uint32_t8uint32_tRK15TensorDataTypesRK11TensorTypes" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Constructor with data provided which would be used to create the respective vulkan buffer and memory.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: The physical device to use to fetch properties </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: The device to use to create the buffer and memory from </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: Non-zero-sized vector of data that will be used by the tensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensorTypes</span></code>: Type for the tensor which is of type TensorTypes </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6TensorD0Ev">
<span id="_CPPv3N2kp6TensorD0Ev"></span><span id="_CPPv2N2kp6TensorD0Ev"></span><span id="kp::Tensor::~Tensor"></span><span class="target" id="classkp_1_1Tensor_1ab71ac92ecaac55d9bcc75f1571bfd47f"></span><code class="sig-name descname">~Tensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6TensorD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destructor which is in charge of freeing vulkan resources unless they have been provided externally. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor7rebuildEPv8uint32_t8uint32_t">
<span id="_CPPv3N2kp6Tensor7rebuildEPv8uint32_t8uint32_t"></span><span id="_CPPv2N2kp6Tensor7rebuildEPv8uint32_t8uint32_t"></span><span id="kp::Tensor::rebuild__voidP.uint32_t.uint32_t"></span><span class="target" id="classkp_1_1Tensor_1aece585e97c20ed7133fdfe9fabed9bd6"></span>void <code class="sig-name descname">rebuild</code><span class="sig-paren">(</span>void *<em>data</em>, uint32_t <em>elementTotalCount</em>, uint32_t <em>elementMemorySize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor7rebuildEPv8uint32_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Function to trigger reinitialisation of the tensor buffer and memory with new data as well as new potential device type.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: Vector of data to use to initialise vector from </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensorType</span></code>: The type to use for the tensor </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor7destroyEv">
<span id="_CPPv3N2kp6Tensor7destroyEv"></span><span id="_CPPv2N2kp6Tensor7destroyEv"></span><span id="kp::Tensor::destroy"></span><span class="target" id="classkp_1_1Tensor_1a5cdbcb7abaad8f3e3a392741ea5ad275"></span>void <code class="sig-name descname">destroy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor7destroyEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destroys and frees the GPU resources which include the buffer and memory. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor6isInitEv">
<span id="_CPPv3N2kp6Tensor6isInitEv"></span><span id="_CPPv2N2kp6Tensor6isInitEv"></span><span id="kp::Tensor::isInit"></span><span class="target" id="classkp_1_1Tensor_1af2ae7f0b57fd8e57570ab63962a97f36"></span>bool <code class="sig-name descname">isInit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor6isInitEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Check whether tensor is initialized based on the created gpu resources.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating whether tensor is initialized </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor10tensorTypeEv">
<span id="_CPPv3N2kp6Tensor10tensorTypeEv"></span><span id="_CPPv2N2kp6Tensor10tensorTypeEv"></span><span id="kp::Tensor::tensorType"></span><span class="target" id="classkp_1_1Tensor_1a59452f1c62fd738536bb0a6cbf8d896b"></span><a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a> <code class="sig-name descname">tensorType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor10tensorTypeEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Retrieve the tensor type of the <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> type of tensor </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor14recordCopyFromERKN2vk13CommandBufferENSt10shared_ptrI6TensorEE">
<span id="_CPPv3N2kp6Tensor14recordCopyFromERKN2vk13CommandBufferENSt10shared_ptrI6TensorEE"></span><span id="_CPPv2N2kp6Tensor14recordCopyFromERKN2vk13CommandBufferENSt10shared_ptrI6TensorEE"></span><span id="kp::Tensor::recordCopyFrom__vk::CommandBufferCR.std::shared_ptr:Tensor:"></span><span class="target" id="classkp_1_1Tensor_1afe8b7b81913863523c7a3e580cf91d8e"></span>void <code class="sig-name descname">recordCopyFrom</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt; <em>copyFromTensor</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor14recordCopyFromERKN2vk13CommandBufferENSt10shared_ptrI6TensorEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records a copy from the memory of the tensor provided to the current thensor. This is intended to pass memory into a processing, to perform a staging buffer transfer, or to gather output (between others).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record the commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">copyFromTensor</span></code>: <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> to copy the data from </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor29recordCopyFromStagingToDeviceERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp6Tensor29recordCopyFromStagingToDeviceERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp6Tensor29recordCopyFromStagingToDeviceERKN2vk13CommandBufferE"></span><span id="kp::Tensor::recordCopyFromStagingToDevice__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1Tensor_1ac565adf645121120c0b9ec31c04c743b"></span>void <code class="sig-name descname">recordCopyFromStagingToDevice</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor29recordCopyFromStagingToDeviceERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records a copy from the internal staging memory to the device memory using an optional barrier to wait for the operation. This function would only be relevant for kp::Tensors of type eDevice.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record the commands into </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor29recordCopyFromDeviceToStagingERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp6Tensor29recordCopyFromDeviceToStagingERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp6Tensor29recordCopyFromDeviceToStagingERKN2vk13CommandBufferE"></span><span id="kp::Tensor::recordCopyFromDeviceToStaging__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1Tensor_1ab4be54f0063ffc1687006d6f0b417fcb"></span>void <code class="sig-name descname">recordCopyFromDeviceToStaging</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor29recordCopyFromDeviceToStagingERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records a copy from the internal device memory to the staging memory using an optional barrier to wait for the operation. This function would only be relevant for kp::Tensors of type eDevice.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record the commands into </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor32recordPrimaryBufferMemoryBarrierERKN2vk13CommandBufferEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE">
<span id="_CPPv3N2kp6Tensor32recordPrimaryBufferMemoryBarrierERKN2vk13CommandBufferEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE"></span><span id="_CPPv2N2kp6Tensor32recordPrimaryBufferMemoryBarrierERKN2vk13CommandBufferEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE"></span><span id="kp::Tensor::recordPrimaryBufferMemoryBarrier__vk::CommandBufferCR.vk::AccessFlagBits.vk::AccessFlagBits.vk::PipelineStageFlagBits.vk::PipelineStageFlagBits"></span><span class="target" id="classkp_1_1Tensor_1a1bacad91d866079585f18feb3ec6d8f7"></span>void <code class="sig-name descname">recordPrimaryBufferMemoryBarrier</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em>, vk::AccessFlagBits <em>srcAccessMask</em>, vk::AccessFlagBits <em>dstAccessMask</em>, vk::PipelineStageFlagBits <em>srcStageMask</em>, vk::PipelineStageFlagBits <em>dstStageMask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor32recordPrimaryBufferMemoryBarrierERKN2vk13CommandBufferEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records the buffer memory barrier into the primary buffer and command buffer which ensures that relevant data transfers are carried out correctly.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record the commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">srcAccessMask</span></code>: Access flags for source access mask </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dstAccessMask</span></code>: Access flags for destination access mask </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scrStageMask</span></code>: Pipeline stage flags for source stage mask </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dstStageMask</span></code>: Pipeline stage flags for destination stage mask </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor32recordStagingBufferMemoryBarrierERKN2vk13CommandBufferEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE">
<span id="_CPPv3N2kp6Tensor32recordStagingBufferMemoryBarrierERKN2vk13CommandBufferEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE"></span><span id="_CPPv2N2kp6Tensor32recordStagingBufferMemoryBarrierERKN2vk13CommandBufferEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE"></span><span id="kp::Tensor::recordStagingBufferMemoryBarrier__vk::CommandBufferCR.vk::AccessFlagBits.vk::AccessFlagBits.vk::PipelineStageFlagBits.vk::PipelineStageFlagBits"></span><span class="target" id="classkp_1_1Tensor_1ae1c2ef6acb0b74dcba7d92c870b2daa1"></span>void <code class="sig-name descname">recordStagingBufferMemoryBarrier</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em>, vk::AccessFlagBits <em>srcAccessMask</em>, vk::AccessFlagBits <em>dstAccessMask</em>, vk::PipelineStageFlagBits <em>srcStageMask</em>, vk::PipelineStageFlagBits <em>dstStageMask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor32recordStagingBufferMemoryBarrierERKN2vk13CommandBufferEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records the buffer memory barrier into the staging buffer and command buffer which ensures that relevant data transfers are carried out correctly.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record the commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">srcAccessMask</span></code>: Access flags for source access mask </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dstAccessMask</span></code>: Access flags for destination access mask </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scrStageMask</span></code>: Pipeline stage flags for source stage mask </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dstStageMask</span></code>: Pipeline stage flags for destination stage mask </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor29constructDescriptorBufferInfoEv">
<span id="_CPPv3N2kp6Tensor29constructDescriptorBufferInfoEv"></span><span id="_CPPv2N2kp6Tensor29constructDescriptorBufferInfoEv"></span><span id="kp::Tensor::constructDescriptorBufferInfo"></span><span class="target" id="classkp_1_1Tensor_1a805e6050a935763488116e071c0ce461"></span>vk::DescriptorBufferInfo <code class="sig-name descname">constructDescriptorBufferInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor29constructDescriptorBufferInfoEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Constructs a vulkan descriptor buffer info which can be used to specify and reference the underlying buffer component of the tensor without exposing it.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Descriptor buffer info with own buffer </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor4sizeEv">
<span id="_CPPv3N2kp6Tensor4sizeEv"></span><span id="_CPPv2N2kp6Tensor4sizeEv"></span><span id="kp::Tensor::size"></span><span class="target" id="classkp_1_1Tensor_1a1fb937df6cc482c1f37c74d8fab0f9a9"></span>uint32_t <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor4sizeEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns the size/magnitude of the <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a>, which will be the total number of elements across all dimensions</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Unsigned integer representing the total number of elements </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor18dataTypeMemorySizeEv">
<span id="_CPPv3N2kp6Tensor18dataTypeMemorySizeEv"></span><span id="_CPPv2N2kp6Tensor18dataTypeMemorySizeEv"></span><span id="kp::Tensor::dataTypeMemorySize"></span><span class="target" id="classkp_1_1Tensor_1a47634859d03a074e27084589e5c0511d"></span>uint32_t <code class="sig-name descname">dataTypeMemorySize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor18dataTypeMemorySizeEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns the total size of a single element of the respective data type that this tensor holds.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Unsigned integer representing the memory of a single element of the respective data type. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor10memorySizeEv">
<span id="_CPPv3N2kp6Tensor10memorySizeEv"></span><span id="_CPPv2N2kp6Tensor10memorySizeEv"></span><span id="kp::Tensor::memorySize"></span><span class="target" id="classkp_1_1Tensor_1a4be971eaffcb3192c46c6e49a3fe2773"></span>uint32_t <code class="sig-name descname">memorySize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor10memorySizeEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns the total memory size of the data contained by the <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> object which would equate to (this-&gt;<a class="reference internal" href="#classkp_1_1Tensor_1a1fb937df6cc482c1f37c74d8fab0f9a9"><span class="std std-ref">size()</span></a> * this-&gt;<a class="reference internal" href="#classkp_1_1Tensor_1a47634859d03a074e27084589e5c0511d"><span class="std std-ref">dataTypeMemorySize()</span></a>)</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Unsigned integer representing the memory of a single element of the respective data type. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor8dataTypeEv">
<span id="_CPPv3N2kp6Tensor8dataTypeEv"></span><span id="_CPPv2N2kp6Tensor8dataTypeEv"></span><span id="kp::Tensor::dataType"></span><span class="target" id="classkp_1_1Tensor_1a4addb015014f14da3d6019400c9771e4"></span>TensorDataTypes <code class="sig-name descname">dataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor8dataTypeEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Retrieve the data type of the tensor (host, device, storage)</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Data type of tensor of type kp::Tensor::TensorDataTypes </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor7rawDataEv">
<span id="_CPPv3N2kp6Tensor7rawDataEv"></span><span id="_CPPv2N2kp6Tensor7rawDataEv"></span><span id="kp::Tensor::rawData"></span><span class="target" id="classkp_1_1Tensor_1a3f554cac913805efb542243fcc94d252"></span>void *<code class="sig-name descname">rawData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor7rawDataEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Retrieve the raw data via the pointer to the memory that contains the raw memory of this current tensor. This tensor gets changed to a nullptr when the <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> is removed.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Pointer to raw memory containing raw bytes data of <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a>. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor10setRawDataEPKv">
<span id="_CPPv3N2kp6Tensor10setRawDataEPKv"></span><span id="_CPPv2N2kp6Tensor10setRawDataEPKv"></span><span id="kp::Tensor::setRawData__voidCP"></span><span class="target" id="classkp_1_1Tensor_1a70b8a0e812aa2746726052c4bfa7307e"></span>void <code class="sig-name descname">setRawData</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor10setRawDataEPKv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Sets / resets the data of the tensor which is directly done on the GPU host visible memory available by the tensor. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0EN2kp6Tensor4dataEP1Tv">
<span id="_CPPv3I0EN2kp6Tensor4dataEv"></span><span id="_CPPv2I0EN2kp6Tensor4dataEv"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br/><span class="target" id="classkp_1_1Tensor_1af4c8d1bdeb1e057bd0d1aea1207bc98e"></span><a class="reference internal" href="#_CPPv4I0EN2kp6Tensor4dataEP1Tv" title="kp::Tensor::data::T">T</a> *<code class="sig-name descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN2kp6Tensor4dataEP1Tv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Template to return the pointer data converted by specific type, which would be any of the supported types including float, double, int32, uint32 and bool.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Pointer to raw memory containing raw bytes data of <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a>. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0EN2kp6Tensor6vectorENSt6vectorI1TEEv">
<span id="_CPPv3I0EN2kp6Tensor6vectorEv"></span><span id="_CPPv2I0EN2kp6Tensor6vectorEv"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br/><span class="target" id="classkp_1_1Tensor_1a0f59eceb0e7440501e11e1c8af598e84"></span>std::vector&lt;<a class="reference internal" href="#_CPPv4I0EN2kp6Tensor6vectorENSt6vectorI1TEEv" title="kp::Tensor::vector::T">T</a>&gt; <code class="sig-name descname">vector</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN2kp6Tensor6vectorENSt6vectorI1TEEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Template to get the data of the current tensor as a vector of specific type, which would be any of the supported types including float, double, int32, uint32 and bool.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Vector of type provided by template. </p>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="algorithm">
<h2 id="algorithm">Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::Algorithm</span></code> consists primarily of the components required for shader code execution, including the relevant vk::DescriptorSet relatedresources as well as vk::Pipeline and all the relevant Vulkan SDK resources as outlined in the architectural diagram.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-algorithm.jpg"><img alt="../_images/kompute-vulkan-architecture-algorithm.jpg" src="../_images/kompute-vulkan-architecture-algorithm.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp9AlgorithmE">
<span id="_CPPv3N2kp9AlgorithmE"></span><span id="_CPPv2N2kp9AlgorithmE"></span><span id="kp::Algorithm"></span><span class="target" id="classkp_1_1Algorithm"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Algorithm</code><a class="headerlink" href="#_CPPv4N2kp9AlgorithmE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Abstraction for compute shaders that are run on top of tensors grouped via ParameterGroups (which group descriptorsets) </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4I00EN2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE">
<span id="_CPPv3I00EN2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE"></span><span id="_CPPv2I00EN2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE"></span>template&lt;typename <code class="sig-name descname">S</code> = float, typename <code class="sig-name descname">P</code> = float&gt;<br/><span class="target" id="classkp_1_1Algorithm_1a68f76649c667ff73ac6aac8775440b62"></span><code class="sig-name descname">Algorithm</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::Device&gt; <em>device</em>, <em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em> = {}, <em class="property">const</em> std::vector&lt;uint32_t&gt; &amp;<em>spirv</em> = {}, <em class="property">const</em> Workgroup &amp;<em>workgroup</em> = {}, <em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I00EN2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE" title="kp::Algorithm::Algorithm::S">S</a>&gt; &amp;<em>specializationConstants</em> = {}, <em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I00EN2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE" title="kp::Algorithm::Algorithm::P">P</a>&gt; &amp;<em>pushConstants</em> = {}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Main constructor for algorithm with configuration parameters to create the underlying resources.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: The Vulkan device to use for creating resources </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: (optional) The tensors to use to create the descriptor resources </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spirv</span></code>: (optional) The spirv code to use to create the algorithm </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code>: (optional) The kp::Workgroup to use for the dispatch which defaults to kp::Workgroup(tensor[0].size(), 1, 1) if not set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">specializationConstants</span></code>: (optional) The templatable param is to be used to initialize the specialization constants which cannot be changed once set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pushConstants</span></code>: (optional) This templatable param is to be used when initializing the pipeline, which set the size of the push constants<ul>
<li><p>these can be modified but all new values must have the same data type and length as otherwise it will result in errors. </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I00EN2kp9Algorithm7rebuildEvRKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE">
<span id="_CPPv3I00EN2kp9Algorithm7rebuildERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE"></span><span id="_CPPv2I00EN2kp9Algorithm7rebuildERKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE"></span>template&lt;typename <code class="sig-name descname">S</code> = float, typename <code class="sig-name descname">P</code> = float&gt;<br/><span class="target" id="classkp_1_1Algorithm_1a266172db410310734fcc57dc5068b62c"></span>void <code class="sig-name descname">rebuild</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em>, <em class="property">const</em> std::vector&lt;uint32_t&gt; &amp;<em>spirv</em>, <em class="property">const</em> Workgroup &amp;<em>workgroup</em> = {}, <em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I00EN2kp9Algorithm7rebuildEvRKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE" title="kp::Algorithm::rebuild::S">S</a>&gt; &amp;<em>specializationConstants</em> = {}, <em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I00EN2kp9Algorithm7rebuildEvRKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE" title="kp::Algorithm::rebuild::P">P</a>&gt; &amp;<em>pushConstants</em> = {}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN2kp9Algorithm7rebuildEvRKNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorI8uint32_tEERK9WorkgroupRKNSt6vectorI1SEERKNSt6vectorI1PEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Rebuild function to reconstruct algorithm with configuration parameters to create the underlying resources.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: The tensors to use to create the descriptor resources </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spirv</span></code>: The spirv code to use to create the algorithm </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code>: (optional) The kp::Workgroup to use for the dispatch which defaults to kp::Workgroup(tensor[0].size(), 1, 1) if not set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">specializationConstants</span></code>: (optional) The std::vector&lt;float&gt; to use to initialize the specialization constants which cannot be changed once set. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pushConstants</span></code>: (optional) The std::vector&lt;float&gt; to use when initializing the pipeline, which set the size of the push constants - these can be modified but all new values must have the same vector size as this initial value. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9AlgorithmD0Ev">
<span id="_CPPv3N2kp9AlgorithmD0Ev"></span><span id="_CPPv2N2kp9AlgorithmD0Ev"></span><span id="kp::Algorithm::~Algorithm"></span><span class="target" id="classkp_1_1Algorithm_1a8bb732b02135afeec7e80e7a2c5d3ce7"></span><code class="sig-name descname">~Algorithm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9AlgorithmD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destructor for <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> which is responsible for freeing and desroying respective pipelines and owned parameter groups. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm14recordDispatchERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp9Algorithm14recordDispatchERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp9Algorithm14recordDispatchERKN2vk13CommandBufferE"></span><span id="kp::Algorithm::recordDispatch__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1Algorithm_1aa8ee096b6a4f8ae46f62273220c35423"></span>void <code class="sig-name descname">recordDispatch</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm14recordDispatchERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records the dispatch function with the provided template parameters or alternatively using the size of the tensor by default.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Command buffer to record the algorithm resources to </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm14recordBindCoreERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp9Algorithm14recordBindCoreERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp9Algorithm14recordBindCoreERKN2vk13CommandBufferE"></span><span id="kp::Algorithm::recordBindCore__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1Algorithm_1a02656689952580a83d5f8d2c769a041e"></span>void <code class="sig-name descname">recordBindCore</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm14recordBindCoreERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records command that binds the “core” algorithm components which consist of binding the pipeline and binding the descriptorsets.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Command buffer to record the algorithm resources to </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm14recordBindPushERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp9Algorithm14recordBindPushERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp9Algorithm14recordBindPushERKN2vk13CommandBufferE"></span><span id="kp::Algorithm::recordBindPush__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1Algorithm_1a4e3277dff114031c091475a12fb3cd23"></span>void <code class="sig-name descname">recordBindPush</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm14recordBindPushERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records command that binds the push constants to the command buffer provided<ul class="simple">
<li><p>it is required that the pushConstants provided are of the same size as the ones provided during initialization.</p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Command buffer to record the algorithm resources to </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm6isInitEv">
<span id="_CPPv3N2kp9Algorithm6isInitEv"></span><span id="_CPPv2N2kp9Algorithm6isInitEv"></span><span id="kp::Algorithm::isInit"></span><span class="target" id="classkp_1_1Algorithm_1a974ac8dd9f100fd4ed3ef71312314bda"></span>bool <code class="sig-name descname">isInit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm6isInitEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>function that checks all the gpu resource components to verify if these have been created and returns true if all are valid.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>returns true if the algorithm is currently initialized. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm12setWorkgroupERK9Workgroup8uint32_t">
<span id="_CPPv3N2kp9Algorithm12setWorkgroupERK9Workgroup8uint32_t"></span><span id="_CPPv2N2kp9Algorithm12setWorkgroupERK9Workgroup8uint32_t"></span><span id="kp::Algorithm::setWorkgroup__WorkgroupCR.uint32_t"></span><span class="target" id="classkp_1_1Algorithm_1a3f195f84f2e30d5913776a6610c52c19"></span>void <code class="sig-name descname">setWorkgroup</code><span class="sig-paren">(</span><em class="property">const</em> Workgroup &amp;<em>workgroup</em>, uint32_t <em>minSize</em> = 1<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm12setWorkgroupERK9Workgroup8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Sets the work group to use in the recordDispatch</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">workgroup</span></code>: The kp::Workgroup value to use to update the algorithm. It must have a value greater than 1 on the x value (index 1) otherwise it will be initialized on the size of the first tensor (ie. this-&gt;mTensor[0]-&gt;size()) </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0EN2kp9Algorithm16setPushConstantsEvRKNSt6vectorI1TEE">
<span id="_CPPv3I0EN2kp9Algorithm16setPushConstantsERKNSt6vectorI1TEE"></span><span id="_CPPv2I0EN2kp9Algorithm16setPushConstantsERKNSt6vectorI1TEE"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br/><span class="target" id="classkp_1_1Algorithm_1a45c9565ad7fd9ec76ef2b4ca39385dae"></span>void <code class="sig-name descname">setPushConstants</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I0EN2kp9Algorithm16setPushConstantsEvRKNSt6vectorI1TEE" title="kp::Algorithm::setPushConstants::T">T</a>&gt; &amp;<em>pushConstants</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN2kp9Algorithm16setPushConstantsEvRKNSt6vectorI1TEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Sets the push constants to the new value provided to use in the next bindPush()</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pushConstants</span></code>: The templatable vector is to be used to set the push constants to use in the next bindPush(…) calls. The constants provided must be of the same size as the ones created during initialization. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm16setPushConstantsEPv8uint32_t8uint32_t">
<span id="_CPPv3N2kp9Algorithm16setPushConstantsEPv8uint32_t8uint32_t"></span><span id="_CPPv2N2kp9Algorithm16setPushConstantsEPv8uint32_t8uint32_t"></span><span id="kp::Algorithm::setPushConstants__voidP.uint32_t.uint32_t"></span><span class="target" id="classkp_1_1Algorithm_1aac3e21c65a28772e01c8ef45794a1943"></span>void <code class="sig-name descname">setPushConstants</code><span class="sig-paren">(</span>void *<em>data</em>, uint32_t <em>size</em>, uint32_t <em>memorySize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm16setPushConstantsEPv8uint32_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Sets the push constants to the new value provided to use in the next bindPush() with the raw memory block location and memory size to be used.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: The raw data point to copy the data from, without modifying the pointer. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code>: The number of data elements provided in the data </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memorySize</span></code>: The memory size of each of the data elements in bytes. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm12getWorkgroupEv">
<span id="_CPPv3N2kp9Algorithm12getWorkgroupEv"></span><span id="_CPPv2N2kp9Algorithm12getWorkgroupEv"></span><span id="kp::Algorithm::getWorkgroup"></span><span class="target" id="classkp_1_1Algorithm_1a81ce1c093ff2e837f998e9962b2c09e3"></span><em class="property">const</em> Workgroup &amp;<code class="sig-name descname">getWorkgroup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm12getWorkgroupEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Gets the current workgroup from the algorithm.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">The</span></code>: kp::Constant to use to set the push constants to use in the next bindPush(…) calls. The constants provided must be of the same size as the ones created during initialization. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0EN2kp9Algorithm26getSpecializationConstantsEKNSt6vectorI1TEEv">
<span id="_CPPv3I0EN2kp9Algorithm26getSpecializationConstantsEv"></span><span id="_CPPv2I0EN2kp9Algorithm26getSpecializationConstantsEv"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br/><span class="target" id="classkp_1_1Algorithm_1ada43d0bb76b065d7bda857a17a627807"></span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I0EN2kp9Algorithm26getSpecializationConstantsEKNSt6vectorI1TEEv" title="kp::Algorithm::getSpecializationConstants::T">T</a>&gt; <code class="sig-name descname">getSpecializationConstants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN2kp9Algorithm26getSpecializationConstantsEKNSt6vectorI1TEEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Gets the specialization constants of the current algorithm.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The std::vector&lt;float&gt; currently set for specialization constants </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0EN2kp9Algorithm16getPushConstantsEKNSt6vectorI1TEEv">
<span id="_CPPv3I0EN2kp9Algorithm16getPushConstantsEv"></span><span id="_CPPv2I0EN2kp9Algorithm16getPushConstantsEv"></span>template&lt;typename <code class="sig-name descname">T</code>&gt;<br/><span class="target" id="classkp_1_1Algorithm_1ad7fb6842494aec686e32f597df1925f2"></span><em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I0EN2kp9Algorithm16getPushConstantsEKNSt6vectorI1TEEv" title="kp::Algorithm::getPushConstants::T">T</a>&gt; <code class="sig-name descname">getPushConstants</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN2kp9Algorithm16getPushConstantsEKNSt6vectorI1TEEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Gets the specialization constants of the current algorithm.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The std::vector&lt;float&gt; currently set for push constants </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm10getTensorsEv">
<span id="_CPPv3N2kp9Algorithm10getTensorsEv"></span><span id="_CPPv2N2kp9Algorithm10getTensorsEv"></span><span id="kp::Algorithm::getTensors"></span><span class="target" id="classkp_1_1Algorithm_1a899e4fa43bf02bc556920fc3b4b22900"></span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<code class="sig-name descname">getTensors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm10getTensorsEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Gets the current tensors that are used in the algorithm.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>The list of tensors used in the algorithm. </p>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="opbase">
<h2 id="opbase">OpBase<a class="headerlink" href="#opbase" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::OpBase</span></code> provides a top level class for an operation in Kompute, which is the step that is executed on a GPU submission. The Kompute operations can consist of one or more <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::Tensor</span></code>.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-operations.jpg"><img alt="../_images/kompute-vulkan-architecture-operations.jpg" src="../_images/kompute-vulkan-architecture-operations.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp6OpBaseE">
<span id="_CPPv3N2kp6OpBaseE"></span><span id="_CPPv2N2kp6OpBaseE"></span><span id="kp::OpBase"></span><span class="target" id="classkp_1_1OpBase"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpBase</code><a class="headerlink" href="#_CPPv4N2kp6OpBaseE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base Operation which provides the high level interface that Kompute operations implement in order to perform a set of actions in the GPU.</p>
<p>Operations can perform actions on tensors, and optionally can also own an <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> with respective parameters. kp::Operations with kp::Algorithms would inherit from kp::OpBaseAlgo. </p>
<p>Subclassed by <a class="reference internal" href="#classkp_1_1OpAlgoDispatch"><span class="std std-ref">kp::OpAlgoDispatch</span></a>, kp::OpMemoryBarrier, <a class="reference internal" href="#classkp_1_1OpTensorCopy"><span class="std std-ref">kp::OpTensorCopy</span></a>, kp::OpTensorSyncDevice, <a class="reference internal" href="#classkp_1_1OpTensorSyncLocal"><span class="std std-ref">kp::OpTensorSyncLocal</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBaseD0Ev">
<span id="_CPPv3N2kp6OpBaseD0Ev"></span><span id="_CPPv2N2kp6OpBaseD0Ev"></span><span id="kp::OpBase::~OpBase"></span><span class="target" id="classkp_1_1OpBase_1aab3aa15a2a7f6482461a1ff9de3b47af"></span><code class="sig-name descname">~OpBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6OpBaseD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor for <a class="reference internal" href="#classkp_1_1OpBase"><span class="std std-ref">OpBase</span></a> class. This <a class="reference internal" href="#classkp_1_1OpBase"><span class="std std-ref">OpBase</span></a> destructor class should always be called to destroy and free owned resources unless it is intended to destroy the resources in the parent class. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBase6recordERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp6OpBase6recordERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp6OpBase6recordERKN2vk13CommandBufferE"></span><span id="kp::OpBase::record__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpBase_1a49b26daf78e1c4720d950514383019f8"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N2kp6OpBase6recordERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>The record function is intended to only send a record command or run commands that are expected to record operations that are to be submitted as a batch into the GPU.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBase7preEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp6OpBase7preEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp6OpBase7preEvalERKN2vk13CommandBufferE"></span><span id="kp::OpBase::preEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpBase_1a110436486db21e83bdb09f73262c0587"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N2kp6OpBase7preEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Pre eval is called before the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> has called eval and submitted the commands to the GPU for processing, and can be used to perform any per-eval setup steps required as the computation iteration begins. It’s worth noting that there are situations where eval can be called multiple times, so the resources that are created should be idempotent in case it’s called multiple times in a row.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBase8postEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp6OpBase8postEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp6OpBase8postEvalERKN2vk13CommandBufferE"></span><span id="kp::OpBase::postEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpBase_1abf8f8333d659c32dd0543ee2af4f3e61"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N2kp6OpBase8postEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Post eval is called after the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> has called eval and submitted the commands to the GPU for processing, and can be used to perform any tear-down steps required as the computation iteration finishes. It’s worth noting that there are situations where eval can be called multiple times, so the resources that are destroyed should not require a re-init unless explicitly provided by the user.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="opalgodispatch">
<h2 id="opalgodispatch">OpAlgoDispatch<a class="headerlink" href="#opalgodispatch" title="Permalink to this headline">¶</a></h2>
<p>The <cite>vk::OpAlgoDispatch</cite> extends the <cite>vk::OpBase</cite> class, and provides the base for shader-based operations. Besides of consisting of one or more <cite>vk::Tensor</cite> as per the <cite>vk::OpBase</cite>, it also contains a unique <cite>vk::Algorithm</cite>.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-opmult.jpg"><img alt="../_images/kompute-vulkan-architecture-opmult.jpg" src="../_images/kompute-vulkan-architecture-opmult.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp14OpAlgoDispatchE">
<span id="_CPPv3N2kp14OpAlgoDispatchE"></span><span id="_CPPv2N2kp14OpAlgoDispatchE"></span><span id="kp::OpAlgoDispatch"></span><span class="target" id="classkp_1_1OpAlgoDispatch"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpAlgoDispatch</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><a class="headerlink" href="#_CPPv4N2kp14OpAlgoDispatchE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that provides a general abstraction that simplifies the use of algorithm and parameter components which can be used with shaders. By default it enables the user to provide a dynamic number of tensors which are then passed as inputs. </p>
<p>Subclassed by <a class="reference internal" href="#classkp_1_1OpMult"><span class="std std-ref">kp::OpMult</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4I0EN2kp14OpAlgoDispatch14OpAlgoDispatchERKNSt10shared_ptrIN2kp9AlgorithmEEERKNSt6vectorI1TEE">
<span id="_CPPv3I0EN2kp14OpAlgoDispatch14OpAlgoDispatchERKNSt10shared_ptrIN2kp9AlgorithmEEERKNSt6vectorI1TEE"></span><span id="_CPPv2I0EN2kp14OpAlgoDispatch14OpAlgoDispatchERKNSt10shared_ptrIN2kp9AlgorithmEEERKNSt6vectorI1TEE"></span>template&lt;typename <code class="sig-name descname">T</code> = float&gt;<br/><span class="target" id="classkp_1_1OpAlgoDispatch_1ae435647441f630f5860eed6b414cc003"></span><code class="sig-name descname">OpAlgoDispatch</code><span class="sig-paren">(</span><em class="property">const</em> std::shared_ptr&lt;kp::<a class="reference internal" href="#_CPPv4N2kp9AlgorithmE" title="kp::Algorithm">Algorithm</a>&gt; &amp;<em>algorithm</em>, <em class="property">const</em> std::vector&lt;<a class="reference internal" href="#_CPPv4I0EN2kp14OpAlgoDispatch14OpAlgoDispatchERKNSt10shared_ptrIN2kp9AlgorithmEEERKNSt6vectorI1TEE" title="kp::OpAlgoDispatch::OpAlgoDispatch::T">T</a>&gt; &amp;<em>pushConstants</em> = {}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN2kp14OpAlgoDispatch14OpAlgoDispatchERKNSt10shared_ptrIN2kp9AlgorithmEEERKNSt6vectorI1TEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Constructor that stores the algorithm to use as well as the relevant push constants to override when recording.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code>: The algorithm object to use for dispatch </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pushConstants</span></code>: The push constants to use for override </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpAlgoDispatchD0Ev">
<span id="_CPPv3N2kp14OpAlgoDispatchD0Ev"></span><span id="_CPPv2N2kp14OpAlgoDispatchD0Ev"></span><span id="kp::OpAlgoDispatch::~OpAlgoDispatch"></span><span class="target" id="classkp_1_1OpAlgoDispatch_1a809cda4e6f37c57a2807971e6481515b"></span><code class="sig-name descname">~OpAlgoDispatch</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp14OpAlgoDispatchD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor, which is in charge of destroying the algorithm components but does not destroy the underlying tensors </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpAlgoDispatch6recordERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp14OpAlgoDispatch6recordERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp14OpAlgoDispatch6recordERKN2vk13CommandBufferE"></span><span id="kp::OpAlgoDispatch::record__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpAlgoDispatch_1ae1b8e6a0f402859acab6ace0590a9fb9"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp14OpAlgoDispatch6recordERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>This records the commands that are to be sent to the GPU. This includes the barriers that ensure the memory has been copied before going in and out of the shader, as well as the dispatch operation that sends the shader processing to the gpu. This function also records the GPU memory copy of the output data for the staging buffer so it can be read by the host.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpAlgoDispatch7preEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp14OpAlgoDispatch7preEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp14OpAlgoDispatch7preEvalERKN2vk13CommandBufferE"></span><span id="kp::OpAlgoDispatch::preEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpAlgoDispatch_1a4eef6dff7c2b4a88b7a8e96da8888d2c"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp14OpAlgoDispatch7preEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any preEval commands.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpAlgoDispatch8postEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp14OpAlgoDispatch8postEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp14OpAlgoDispatch8postEvalERKN2vk13CommandBufferE"></span><span id="kp::OpAlgoDispatch::postEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpAlgoDispatch_1afdd5d229f12be1798a03ed3ccd2995fc"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp14OpAlgoDispatch8postEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any postEval commands.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="opmult">
<h2 id="opmult">OpMult<a class="headerlink" href="#opmult" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::OpMult</span></code> operation is a sample implementation of the <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::OpAlgoBase</span></code> class. This class shows how it is possible to create a custom vk::OpAlgoBase that can compile as part of the binary. The <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::OpMult</span></code> operation uses the shader-to-cpp-header-file script to convert the script into cpp header files.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-opmult.jpg"><img alt="../_images/kompute-vulkan-architecture-opmult.jpg" src="../_images/kompute-vulkan-architecture-opmult.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp6OpMultE">
<span id="_CPPv3N2kp6OpMultE"></span><span id="_CPPv2N2kp6OpMultE"></span><span id="kp::OpMult"></span><span class="target" id="classkp_1_1OpMult"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpMult</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp14OpAlgoDispatchE" title="kp::OpAlgoDispatch">OpAlgoDispatch</a><a class="headerlink" href="#_CPPv4N2kp6OpMultE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that performs multiplication on two tensors and outpus on third tensor. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpMult6OpMultENSt6vectorINSt10shared_ptrI6TensorEEEENSt10shared_ptrI9AlgorithmEE">
<span id="_CPPv3N2kp6OpMult6OpMultENSt6vectorINSt10shared_ptrI6TensorEEEENSt10shared_ptrI9AlgorithmEE"></span><span id="_CPPv2N2kp6OpMult6OpMultENSt6vectorINSt10shared_ptrI6TensorEEEENSt10shared_ptrI9AlgorithmEE"></span><span id="kp::OpMult::OpMult__std::vector:std::shared_ptr:Tensor::.std::shared_ptr:Algorithm:"></span><span class="target" id="classkp_1_1OpMult_1a61e02be5bc3184f900a1f2a411a18e25"></span><code class="sig-name descname">OpMult</code><span class="sig-paren">(</span>std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp9AlgorithmE" title="kp::Algorithm">Algorithm</a>&gt; <em>algorithm</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6OpMult6OpMultENSt6vectorINSt10shared_ptrI6TensorEEEENSt10shared_ptrI9AlgorithmEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the bare minimum requirements for the operations to be able to create and manage their sub-components.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that are to be used in this operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code>: An algorithm that will be overridden with the <a class="reference internal" href="#classkp_1_1OpMult"><span class="std std-ref">OpMult</span></a> shader data and the tensors provided which are expected to be 3 </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpMultD0Ev">
<span id="_CPPv3N2kp6OpMultD0Ev"></span><span id="_CPPv2N2kp6OpMultD0Ev"></span><span id="kp::OpMult::~OpMult"></span><span class="target" id="classkp_1_1OpMult_1a5f6bcf968416f6d434f849dbe510d269"></span><code class="sig-name descname">~OpMult</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp6OpMultD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor, which is in charge of destroying the algorithm components but does not destroy the underlying tensors </p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="optensorcopy">
<h2 id="optensorcopy">OpTensorCopy<a class="headerlink" href="#optensorcopy" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::OpTensorCopy</span></code> is a tensor only operation that copies the GPU memory buffer data from one <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::Tensor</span></code> to one or more subsequent tensors.</p>
<dl class="cpp class">
<dt id="_CPPv4N2kp12OpTensorCopyE">
<span id="_CPPv3N2kp12OpTensorCopyE"></span><span id="_CPPv2N2kp12OpTensorCopyE"></span><span id="kp::OpTensorCopy"></span><span class="target" id="classkp_1_1OpTensorCopy"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpTensorCopy</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopyE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that copies the data from the first tensor to the rest of the tensors provided, using a record command for all the vectors. This operation does not own/manage the memory of the tensors passed to it. The operation must only receive tensors of type </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopy12OpTensorCopyERKNSt6vectorINSt10shared_ptrI6TensorEEEE">
<span id="_CPPv3N2kp12OpTensorCopy12OpTensorCopyERKNSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="_CPPv2N2kp12OpTensorCopy12OpTensorCopyERKNSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="kp::OpTensorCopy::OpTensorCopy__std::vector:std::shared_ptr:Tensor::CR"></span><span class="target" id="classkp_1_1OpTensorCopy_1a332116c77ff4795e634b093b24e9de18"></span><code class="sig-name descname">OpTensorCopy</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopy12OpTensorCopyERKNSt6vectorINSt10shared_ptrI6TensorEEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the core vulkan resources and the tensors that will be used in the operation.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that will be used to create in operation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopyD0Ev">
<span id="_CPPv3N2kp12OpTensorCopyD0Ev"></span><span id="_CPPv2N2kp12OpTensorCopyD0Ev"></span><span id="kp::OpTensorCopy::~OpTensorCopy"></span><span class="target" id="classkp_1_1OpTensorCopy_1acfde203e1614298ace93389f5fdb0564"></span><code class="sig-name descname">~OpTensorCopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopyD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor. This class does not manage memory so it won’t be expecting the parent to perform a release. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopy6recordERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp12OpTensorCopy6recordERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp12OpTensorCopy6recordERKN2vk13CommandBufferE"></span><span id="kp::OpTensorCopy::record__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpTensorCopy_1a5e24af34f32cd3f9511113b47f95877d"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopy6recordERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records the copy commands from the first tensor into all the other tensors provided. Also optionally records a barrier.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopy7preEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp12OpTensorCopy7preEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp12OpTensorCopy7preEvalERKN2vk13CommandBufferE"></span><span id="kp::OpTensorCopy::preEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpTensorCopy_1ad8acbf4b1ae712300e4882d88ece0976"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopy7preEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any preEval commands.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopy8postEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp12OpTensorCopy8postEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp12OpTensorCopy8postEvalERKN2vk13CommandBufferE"></span><span id="kp::OpTensorCopy::postEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpTensorCopy_1a5383b711faae74ee42a6d1d688e0be1c"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopy8postEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Copies the local vectors for all the tensors to sync the data with the gpu.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="optensorsynclocal">
<h2 id="optensorsynclocal">OpTensorSyncLocal<a class="headerlink" href="#optensorsynclocal" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::OpTensorSyncLocal</span></code> is a tensor only operation that maps the data from the GPU device memory into the local host vector.</p>
<dl class="cpp class">
<dt id="_CPPv4N2kp17OpTensorSyncLocalE">
<span id="_CPPv3N2kp17OpTensorSyncLocalE"></span><span id="_CPPv2N2kp17OpTensorSyncLocalE"></span><span id="kp::OpTensorSyncLocal"></span><span class="target" id="classkp_1_1OpTensorSyncLocal"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpTensorSyncLocal</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocalE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that syncs tensor’s local memory by mapping device data into the local CPU memory. For TensorTypes::eDevice it will use a record operation for the memory to be syncd into GPU memory which means that the operation will be done in sync with GPU commands. For TensorTypes::eHost it will only map the data into host memory which will happen during preEval before the recorded commands are dispatched. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocal17OpTensorSyncLocalERKNSt6vectorINSt10shared_ptrI6TensorEEEE">
<span id="_CPPv3N2kp17OpTensorSyncLocal17OpTensorSyncLocalERKNSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="_CPPv2N2kp17OpTensorSyncLocal17OpTensorSyncLocalERKNSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="kp::OpTensorSyncLocal::OpTensorSyncLocal__std::vector:std::shared_ptr:Tensor::CR"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1ad427093c4065143a711133bd75207406"></span><code class="sig-name descname">OpTensorSyncLocal</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocal17OpTensorSyncLocalERKNSt6vectorINSt10shared_ptrI6TensorEEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the core vulkan resources and the tensors that will be used in the operation. The tensors provided cannot be of type TensorTypes::eStorage.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that will be used to create in operation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocalD0Ev">
<span id="_CPPv3N2kp17OpTensorSyncLocalD0Ev"></span><span id="_CPPv2N2kp17OpTensorSyncLocalD0Ev"></span><span id="kp::OpTensorSyncLocal::~OpTensorSyncLocal"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1abe9a817363d192a190b93cf520449397"></span><code class="sig-name descname">~OpTensorSyncLocal</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocalD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor. This class does not manage memory so it won’t be expecting the parent to perform a release. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocal6recordERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp17OpTensorSyncLocal6recordERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp17OpTensorSyncLocal6recordERKN2vk13CommandBufferE"></span><span id="kp::OpTensorSyncLocal::record__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1ab29b7d2328f1288991b28c2ca6f9ec3b"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocal6recordERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>For device tensors, it records the copy command for the tensor to copy the data from its device to staging memory.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocal7preEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp17OpTensorSyncLocal7preEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp17OpTensorSyncLocal7preEvalERKN2vk13CommandBufferE"></span><span id="kp::OpTensorSyncLocal::preEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1af517bbd1bf2043247c1814771669cf6c"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocal7preEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any preEval commands.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocal8postEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp17OpTensorSyncLocal8postEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp17OpTensorSyncLocal8postEvalERKN2vk13CommandBufferE"></span><span id="kp::OpTensorSyncLocal::postEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1aeb180833e8c7906cd66e1eabb65631c7"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocal8postEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>For host tensors it performs the map command from the host memory into local memory.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="optensorsyncdevice">
<h2 id="optensorsyncdevice">OpTensorSyncDevice<a class="headerlink" href="#optensorsyncdevice" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::OpTensorSyncDevice</span></code> is a tensor only operation that maps the data from the local host vector into the GPU device memory.</p>
<dl class="cpp class">
<dt id="_CPPv4N2kp18OpTensorSyncDeviceE">
<span id="_CPPv3N2kp18OpTensorSyncDeviceE"></span><span id="_CPPv2N2kp18OpTensorSyncDeviceE"></span><span id="kp::OpTensorSyncDevice"></span><span class="target" id="classkp_1_1OpTensorSyncDevice"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpTensorSyncDevice</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDeviceE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that syncs tensor’s device by mapping local data into the device memory. For TensorTypes::eDevice it will use a record operation for the memory to be syncd into GPU memory which means that the operation will be done in sync with GPU commands. For TensorTypes::eHost it will only map the data into host memory which will happen during preEval before the recorded commands are dispatched. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDevice18OpTensorSyncDeviceERKNSt6vectorINSt10shared_ptrI6TensorEEEE">
<span id="_CPPv3N2kp18OpTensorSyncDevice18OpTensorSyncDeviceERKNSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="_CPPv2N2kp18OpTensorSyncDevice18OpTensorSyncDeviceERKNSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="kp::OpTensorSyncDevice::OpTensorSyncDevice__std::vector:std::shared_ptr:Tensor::CR"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1a482b739eac339555ca6183f19e850300"></span><code class="sig-name descname">OpTensorSyncDevice</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDevice18OpTensorSyncDeviceERKNSt6vectorINSt10shared_ptrI6TensorEEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the core vulkan resources and the tensors that will be used in the operation. The tensos provided cannot be of type TensorTypes::eStorage.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that will be used to create in operation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDeviceD0Ev">
<span id="_CPPv3N2kp18OpTensorSyncDeviceD0Ev"></span><span id="_CPPv2N2kp18OpTensorSyncDeviceD0Ev"></span><span id="kp::OpTensorSyncDevice::~OpTensorSyncDevice"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1a990df433f503d85828392e4d50db77c1"></span><code class="sig-name descname">~OpTensorSyncDevice</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDeviceD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor. This class does not manage memory so it won’t be expecting the parent to perform a release. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDevice6recordERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp18OpTensorSyncDevice6recordERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp18OpTensorSyncDevice6recordERKN2vk13CommandBufferE"></span><span id="kp::OpTensorSyncDevice::record__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1a93f73c1d9a154ae1518dec924519cdb4"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDevice6recordERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>For device tensors, it records the copy command for the tensor to copy the data from its staging to device memory.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDevice7preEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp18OpTensorSyncDevice7preEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp18OpTensorSyncDevice7preEvalERKN2vk13CommandBufferE"></span><span id="kp::OpTensorSyncDevice::preEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1a36094f5e8304432ba1adb018f0d2ecb6"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDevice7preEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any preEval commands.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDevice8postEvalERKN2vk13CommandBufferE">
<span id="_CPPv3N2kp18OpTensorSyncDevice8postEvalERKN2vk13CommandBufferE"></span><span id="_CPPv2N2kp18OpTensorSyncDevice8postEvalERKN2vk13CommandBufferE"></span><span id="kp::OpTensorSyncDevice::postEval__vk::CommandBufferCR"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1afc889aea4c633071afa6214cad0b1bc0"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDevice8postEvalERKN2vk13CommandBufferE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any postEval commands.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>
</section>
<section id="opmemorybarrier">
<h2 id="opmemorybarrier">OpMemoryBarrier<a class="headerlink" href="#opmemorybarrier" title="Permalink to this headline">¶</a></h2>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">kp::OpMemoryBarrier</span></code> is a tensor only operation which adds memory barriers to the tensors provided with the access and stage masks provided.</p>
<dl class="cpp class">
<dt>
<span class="target" id="classkp_1_1OpTensorSyncDevice"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpTensorSyncDevice</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><br/></dt>
<dd><p>Operation that syncs tensor’s device by mapping local data into the device memory. For TensorTypes::eDevice it will use a record operation for the memory to be syncd into GPU memory which means that the operation will be done in sync with GPU commands. For TensorTypes::eHost it will only map the data into host memory which will happen during preEval before the recorded commands are dispatched. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt>
<span class="target" id="classkp_1_1OpTensorSyncDevice_1a482b739eac339555ca6183f19e850300"></span><code class="sig-name descname">OpTensorSyncDevice</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em><span class="sig-paren">)</span><br/></dt>
<dd><p>Default constructor with parameters that provides the core vulkan resources and the tensors that will be used in the operation. The tensos provided cannot be of type TensorTypes::eStorage.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that will be used to create in operation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt>
<span class="target" id="classkp_1_1OpTensorSyncDevice_1a990df433f503d85828392e4d50db77c1"></span><code class="sig-name descname">~OpTensorSyncDevice</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><br/></dt>
<dd><p>Default destructor. This class does not manage memory so it won’t be expecting the parent to perform a release. </p>
</dd></dl>
<dl class="cpp function">
<dt>
<span class="target" id="classkp_1_1OpTensorSyncDevice_1a93f73c1d9a154ae1518dec924519cdb4"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><br/></dt>
<dd><p>For device tensors, it records the copy command for the tensor to copy the data from its staging to device memory.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt>
<span class="target" id="classkp_1_1OpTensorSyncDevice_1a36094f5e8304432ba1adb018f0d2ecb6"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><br/></dt>
<dd><p>Does not perform any preEval commands.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt>
<span class="target" id="classkp_1_1OpTensorSyncDevice_1afc889aea4c633071afa6214cad0b1bc0"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><em class="property">const</em> vk::CommandBuffer &amp;<em>commandBuffer</em><span class="sig-paren">)</span> <em class="property">override</em><br/></dt>
<dd><p>Does not perform any postEval commands.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The command buffer to record the command into. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>
</section>
</section>


          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
            <a href="custom-operations.html" title="Extending Kompute with Custom C++ Operations"
               class="md-flex md-footer-nav__link md-footer-nav__link--prev"
               rel="prev">
              <div class="md-flex__cell md-flex__cell--shrink">
                <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
              </div>
              <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
                <span class="md-flex__ellipsis">
                  <span
                      class="md-footer-nav__direction"> Previous </span> Extending Kompute with Custom C++ Operations </span>
              </div>
            </a>
          
          
            <a href="python-package.html" title="Python Package Overview"
               class="md-flex md-footer-nav__link md-footer-nav__link--next"
               rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span
                class="md-flex__ellipsis"> <span
                class="md-footer-nav__direction"> Next </span> Python Package Overview </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink"><i
                class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2020, The Institute for Ethical AI &amp; Machine Learning.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>